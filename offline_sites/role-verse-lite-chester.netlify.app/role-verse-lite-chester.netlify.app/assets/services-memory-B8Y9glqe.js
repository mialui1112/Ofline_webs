var e=Object.defineProperty,t=Object.defineProperties,n=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,s=(t,n,r)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,a=(e,t)=>{for(var n in t||(t={}))i.call(t,n)&&s(e,n,t[n]);if(r)for(var n of r(t))o.call(t,n)&&s(e,n,t[n]);return e},c=(e,r)=>t(e,n(r)),u=(e,t,n)=>new Promise((r,i)=>{var o=e=>{try{a(n.next(e))}catch(t){i(t)}},s=e=>{try{a(n.throw(e))}catch(t){i(t)}},a=e=>e.done?r(e.value):Promise.resolve(e.value).then(o,s);a((n=n.apply(e,t)).next())});import{g as d,s as h,a as l}from"./services-utils-DBsuzUq6.js";import{d as p,_ as g}from"./services-ai-BnwXY5bg.js";import{D as m}from"./vendor-db-CupY014F.js";import{g as f}from"./vendor-react-C7tYskqo.js";class y extends m{constructor(){super("AITS_VN_DB"),this.version(1).stores({savedGames:"id",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType]"}),this.version(2).stores({savedGames:"id, createdAt, updatedAt, theme",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType], [gameId+createdAt], sourceType, createdAt",memoryAnalytics:"id, gameId, [gameId+timestamp], memoryType, quality",ragPerformance:"id, gameId, [gameId+operationType], timestamp, performance",aiMemoryChunks:"id, gameId, [gameId+chunkType], [gameId+importance], chunkType, importance",semanticClusters:"id, gameId, [gameId+topic], topic, relevanceScore",userInteractions:"id, gameId, [gameId+interactionType], timestamp, interactionType"}),this.version(3).stores({savedGames:"id, createdAt, updatedAt, theme",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType], [gameId+createdAt], sourceType, createdAt",memoryAnalytics:"id, gameId, [gameId+timestamp], memoryType, quality",ragPerformance:"id, gameId, [gameId+operationType], timestamp, performance",aiMemoryChunks:"id, gameId, [gameId+chunkType], [gameId+importance], chunkType, importance",semanticClusters:"id, gameId, [gameId+topic], topic, relevanceScore",userInteractions:"id, gameId, [gameId+interactionType], timestamp, interactionType",performanceLogs:"id, timestamp, operation, sessionId, userId",errorLogs:"id, timestamp, context, sessionId, userId",systemMetrics:"id, timestamp, sessionId, userId",ragStore:"id, content, metadata, relevanceScore",aiMemory:"id, content, relevanceScore, lastAccessed, metadata"}),this.version(4).stores({savedGames:"id, createdAt, updatedAt, theme",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType], [gameId+createdAt], sourceType, createdAt",memoryAnalytics:"id, gameId, [gameId+timestamp], memoryType, quality",ragPerformance:"id, gameId, [gameId+operationType], timestamp, performance",aiMemoryChunks:"id, gameId, [gameId+chunkType], [gameId+importance], chunkType, importance",semanticClusters:"id, gameId, [gameId+topic], topic, relevanceScore",userInteractions:"id, gameId, [gameId+interactionType], timestamp, interactionType",performanceLogs:"id, timestamp, operation, sessionId, userId",errorLogs:"id, timestamp, context, sessionId, userId",systemMetrics:"id, timestamp, sessionId, userId",ragStore:"id, content, metadata, relevanceScore",aiMemory:"id, content, relevanceScore, lastAccessed, metadata",memoryNodes:"id, gameId, type, importance, [gameId+type], [gameId+importance]",memoryHierarchies:"id, gameId, level, importance, [gameId+level]",emotionalContexts:"id, gameId, lastUpdated, [gameId+lastUpdated]",userBehaviorPatterns:"id, userId, gameId, patternType, [userId+gameId], [gameId+patternType]",dynamicPrompts:"id, gameId, lastOptimized, [gameId+lastOptimized]",contextResponses:"id, gameId, timestamp, [gameId+timestamp]",performanceAdaptations:"id, gameId, metric, appliedAt, [gameId+metric]",conversationFlows:"id, gameId, sessionId, lastUpdated, [gameId+sessionId]",userEngagementMetrics:"id, userId, gameId, sessionId, timestamp, [userId+gameId]",aiResponseQuality:"id, gameId, responseId, timestamp, [gameId+timestamp]",predictiveUserModels:"id, userId, gameId, lastUpdated, [userId+gameId]",analyticsInsights:"id, type, severity, timestamp, [type+severity]",adaptationRules:"id, userId, gameId, ruleType, active"}),this.version(5).stores({savedGames:"id, createdAt, updatedAt, theme",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType], [gameId+createdAt], sourceType, createdAt, content",memoryAnalytics:"id, gameId, [gameId+timestamp], memoryType, quality",ragPerformance:"id, gameId, [gameId+operationType], timestamp, performance",aiMemoryChunks:"id, gameId, [gameId+chunkType], [gameId+importance], chunkType, importance",semanticClusters:"id, gameId, [gameId+topic], topic, relevanceScore",userInteractions:"id, gameId, [gameId+interactionType], timestamp, interactionType",performanceLogs:"id, timestamp, operation, sessionId, userId",errorLogs:"id, timestamp, context, sessionId, userId",systemMetrics:"id, timestamp, sessionId, userId",ragStore:"id, content, metadata, relevanceScore",aiMemory:"id, content, relevanceScore, lastAccessed, metadata",memoryNodes:"id, gameId, type, importance, [gameId+type], [gameId+importance]",memoryHierarchies:"id, gameId, level, importance, [gameId+level]",emotionalContexts:"id, gameId, lastUpdated, [gameId+lastUpdated]",userBehaviorPatterns:"id, userId, gameId, patternType, [userId+gameId], [gameId+patternType]",dynamicPrompts:"id, gameId, lastOptimized, [gameId+lastOptimized]",contextResponses:"id, gameId, timestamp, [gameId+timestamp]",performanceAdaptations:"id, gameId, metric, appliedAt, [gameId+metric]",conversationFlows:"id, gameId, timestamp, [gameId+timestamp]",userEngagementMetrics:"id, gameId, timestamp, [gameId+timestamp]",aiResponseQuality:"id, gameId, timestamp, [gameId+timestamp]",predictiveUserModels:"id, userId, gameId, [userId+gameId]",analyticsInsights:"id, gameId, timestamp, [gameId+timestamp]"}),this.version(6).stores({savedGames:"id, createdAt, updatedAt, theme",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType], [gameId+createdAt], sourceType, createdAt, content",memoryAnalytics:"id, gameId, [gameId+timestamp], memoryType, quality",ragPerformance:"id, gameId, [gameId+operationType], timestamp, performance",aiMemoryChunks:"id, gameId, [gameId+chunkType], [gameId+importance], chunkType, importance",semanticClusters:"id, gameId, [gameId+topic], topic, relevanceScore",userInteractions:"id, gameId, [gameId+interactionType], timestamp, interactionType",performanceLogs:"id, timestamp, operation, sessionId, userId",errorLogs:"id, timestamp, context, sessionId, userId",systemMetrics:"id, timestamp, sessionId, userId",ragStore:"id, content, metadata, relevanceScore",aiMemory:"id, content, relevanceScore, lastAccessed, metadata",memoryNodes:"id, gameId, type, importance, [gameId+type], [gameId+importance]",memoryHierarchies:"id, gameId, level, importance, [gameId+level]",emotionalContexts:"id, gameId, lastUpdated, [gameId+lastUpdated]",userBehaviorPatterns:"id, userId, gameId, patternType, [userId+gameId], [gameId+patternType]",dynamicPrompts:"id, gameId, lastOptimized, [gameId+lastOptimized]",contextResponses:"id, gameId, timestamp, [gameId+timestamp]",performanceAdaptations:"id, gameId, metric, appliedAt, [gameId+metric]",conversationFlows:"id, gameId, sessionId, lastUpdated, [gameId+sessionId]",userEngagementMetrics:"id, userId, gameId, sessionId, timestamp, [userId+gameId]",aiResponseQuality:"id, gameId, responseId, timestamp, [gameId+timestamp]",predictiveUserModels:"id, userId, gameId, lastUpdated, [userId+gameId]",analyticsInsights:"id, gameId, timestamp, [gameId+timestamp]",trainingDatasets:"id, createdAt"}),this.version(7).stores({savedGames:"id, createdAt, updatedAt, theme",globalSettings:"id",vectorStore:"id, gameId, [gameId+sourceType], [gameId+createdAt], sourceType, createdAt, content",memoryAnalytics:"id, gameId, [gameId+timestamp], memoryType, quality",ragPerformance:"id, gameId, [gameId+operationType], timestamp, performance",aiMemoryChunks:"id, gameId, [gameId+chunkType], [gameId+importance], chunkType, importance",semanticClusters:"id, gameId, [gameId+topic], topic, relevanceScore",userInteractions:"id, gameId, [gameId+interactionType], timestamp, interactionType",performanceLogs:"id, timestamp, operation, sessionId, userId",errorLogs:"id, timestamp, context, sessionId, userId",systemMetrics:"id, timestamp, sessionId, userId",ragStore:"id, content, metadata, relevanceScore",aiMemory:"id, content, relevanceScore, lastAccessed, metadata",memoryNodes:"id, gameId, type, importance, [gameId+type], [gameId+importance], [context.gameId]",memoryHierarchies:"id, gameId, level, importance, [gameId+level]",emotionalContexts:"id, gameId, lastUpdated, [gameId+lastUpdated]",userBehaviorPatterns:"id, userId, gameId, patternType, [userId+gameId], [gameId+patternType]",dynamicPrompts:"id, gameId, lastOptimized, [gameId+lastOptimized]",contextResponses:"id, gameId, timestamp, [gameId+timestamp]",performanceAdaptations:"id, gameId, metric, appliedAt, [gameId+metric]",conversationFlows:"id, gameId, sessionId, lastUpdated, [gameId+sessionId]",userEngagementMetrics:"id, userId, gameId, sessionId, timestamp, [userId+gameId]",aiResponseQuality:"id, gameId, responseId, timestamp, [gameId+timestamp]",predictiveUserModels:"id, userId, gameId, lastUpdated, [userId+gameId]",analyticsInsights:"id, gameId, timestamp, [gameId+timestamp]",trainingDatasets:"id, createdAt"}),this.on("populate",()=>{this.globalSettings.add(c(a({},p),{id:"currentGlobalSettings"}))})}}const w=new y;function b(){return u(this,null,function*(){return w.savedGames.toArray()})}function v(e){return u(this,null,function*(){return w.savedGames.get(e)})}function A(e){return u(this,null,function*(){const t=yield w.savedGames.put(e);try{const{advancedRAG:t}=yield g(()=>u(null,null,function*(){const{advancedRAG:e}=yield Promise.resolve().then(()=>sr);return{advancedRAG:e}}),void 0,import.meta.url);yield t.saveClustersToDB(e.id)}catch(n){}return t})}function I(e){return u(this,null,function*(){return w.savedGames.delete(e)})}function k(){return u(this,null,function*(){return w.globalSettings.get("currentGlobalSettings")})}function E(e){return u(this,null,function*(){return w.globalSettings.put(c(a({},e),{id:"currentGlobalSettings"}))})}function S(e){return u(this,null,function*(){return w.vectorStore.where("gameId").equals(e).toArray()})}function x(e){return u(this,null,function*(){yield w.vectorStore.add(e)})}function C(e){return u(this,null,function*(){return w.vectorStore.where("gameId").equals(e).delete()})}function M(e,t){return u(this,null,function*(){return w.vectorStore.where("[gameId+sourceType]").equals([e,t]).toArray()})}function _(e,t){return u(this,null,function*(){return w.vectorStore.where("[gameId+sourceType]").equals([e,t]).delete()})}function $(e,t,n){return u(this,null,function*(){const r=(yield w.vectorStore.where("[gameId+sourceType]").equals([e,n]).toArray()).filter(e=>e.sourceDocumentId===t).map(e=>e.id);return yield w.vectorStore.bulkDelete(r),r.length})}function D(e,t){return u(this,null,function*(){const n=yield w.vectorStore.where("[gameId+sourceType]").equals([e,"story_history"]).toArray();return n.sort((e,t)=>{var n,r;const i=Number(null==(n=e.metadata)?void 0:n.turn),o=Number(null==(r=t.metadata)?void 0:r.turn);return isNaN(i)||isNaN(o)||i===o?new Date(e.createdAt).getTime()-new Date(t.createdAt).getTime():i-o}),n.slice(0,t)})}function G(e){return u(this,null,function*(){return e&&0!==e.length?(yield w.vectorStore.bulkDelete(e),e.length):0})}function L(e){return u(this,null,function*(){return w.vectorStore.where("gameId").equals(e).count()})}function N(){return u(this,null,function*(){return w.vectorStore.toArray()})}function T(){return u(this,null,function*(){return w.vectorStore.count()})}function j(e,t,n){return u(this,null,function*(){let r=w.vectorStore.orderBy("id").offset(e).limit(t),i=yield r.toArray();return n&&(i=i.filter(n)),i})}const O=(e,t,n)=>{e({show:!0,title:"common.modal.errorTitle",content:"common.modal.databaseError",substitutions:{operation:t},type:"error"})};function z(e){return u(this,null,function*(){const t=(yield w.memoryAnalytics.where("gameId").equals(e).toArray()).map(e=>e.id);return t.length>0&&(yield w.memoryAnalytics.bulkDelete(t)),t.length})}function P(e){return u(this,null,function*(){const t=(yield w.ragPerformance.where("gameId").equals(e).toArray()).map(e=>e.id);return t.length>0&&(yield w.ragPerformance.bulkDelete(t)),t.length})}function U(e){return u(this,null,function*(){const t=(yield w.aiMemoryChunks.where("gameId").equals(e).toArray()).map(e=>e.id);return t.length>0&&(yield w.aiMemoryChunks.bulkDelete(t)),t.length})}function W(){return u(this,null,function*(){let e=null;try{e=yield w.globalSettings.get("currentGlobalSettings")}catch(t){}w.close(),yield new Promise((e,t)=>{const n=indexedDB.deleteDatabase("AITS_VN_DB");n.onsuccess=()=>e(void 0),n.onerror=()=>t(n.error),n.onblocked=()=>t(new Error("Delete blocked"))}),yield w.open(),e&&(yield w.globalSettings.put(e))})}function q(e,t){return u(this,null,function*(){const n={id:e,dataset:t,createdAt:(new Date).toISOString()};return w.trainingDatasets.put(n)})}function R(){return u(this,null,function*(){return w.trainingDatasets.clear()})}const H=Object.freeze(Object.defineProperty({__proto__:null,GameDB:y,addAIMemoryChunk:function(e){return u(this,null,function*(){return w.aiMemoryChunks.put(e)})},addMemoryAnalytics:function(e){return u(this,null,function*(){return w.memoryAnalytics.add(e)})},addTrainingDataset:q,addVectorEntry:x,cleanupInvalidSavedGames:function(){return u(this,null,function*(){const e=yield w.savedGames.toArray();let t=0;for(const n of e)n.settings&&"string"==typeof n.settings.genre||(yield w.savedGames.delete(n.id),t++);return t})},cleanupOldData:function(e,t=90){return u(this,null,function*(){const e=new Date;e.setDate(e.getDate()-t);let n=0;const r=yield w.ragPerformance.filter(t=>new Date(t.timestamp)<e).toArray();r.length>0&&(yield w.ragPerformance.bulkDelete(r.map(e=>e.id)),n+=r.length);const i=yield w.userInteractions.filter(t=>new Date(t.timestamp)<e).toArray();return i.length>0&&(yield w.userInteractions.bulkDelete(i.map(e=>e.id)),n+=i.length),n})},clearAllTrainingDatasets:R,clearVectorStore:function(){return u(this,null,function*(){return w.vectorStore.clear()})},countVectorEntries:T,countVectorEntriesByGameId:L,createOrUpdateSemanticCluster:function(e){return u(this,null,function*(){return w.semanticClusters.put(e)})},db:w,deleteAIMemoryChunksByGameId:U,deleteAIMemoryChunksByIds:function(e){return u(this,null,function*(){return e&&0!==e.length?(yield w.aiMemoryChunks.bulkDelete(e),e.length):0})},deleteMemoryAnalyticsByGameId:z,deleteMemoryAnalyticsByIds:function(e){return u(this,null,function*(){return e&&0!==e.length?(yield w.memoryAnalytics.bulkDelete(e),e.length):0})},deleteOldMemories:function(e,t=30){return u(this,null,function*(){const n=new Date;n.setDate(n.getDate()-t);const r=(yield w.aiMemoryChunks.where("gameId").equals(e).filter(e=>new Date(e.createdAt)<n).toArray()).map(e=>e.id);return yield w.aiMemoryChunks.bulkDelete(r),r.length})},deleteOldestStoryHistoryVectorEntries:function(e,t){return u(this,null,function*(){const n=yield D(e,Number.MAX_SAFE_INTEGER);if(n.length<=t)return 0;const r=n.slice(0,n.length-t).map(e=>e.id);return yield w.vectorStore.bulkDelete(r),r.length})},deleteRAGPerformanceByGameId:P,deleteRAGPerformanceByIds:function(e){return u(this,null,function*(){return e&&0!==e.length?(yield w.ragPerformance.bulkDelete(e),e.length):0})},deleteSavedGame:I,deleteTrainingDatasetByGameId:function(e){return u(this,null,function*(){return w.trainingDatasets.delete(e)})},deleteVectorEntriesByGameIdAndType:_,deleteVectorEntriesByIds:G,deleteVectorEntriesBySourceDocumentIdAndType:$,deleteVectorEntriesForGame:C,getAllSavedGames:b,getAllVectorEntries:N,getClusterByTopic:function(e,t){return u(this,null,function*(){return w.semanticClusters.where("[gameId+topic]").equals([e,t]).first()})},getClustersByRelevance:function(e,t=.5){return u(this,null,function*(){return w.semanticClusters.where("gameId").equals(e).filter(e=>e.relevanceScore>=t).reverse().sortBy("relevanceScore")})},getDatabaseStats:function(e){return u(this,null,function*(){return{savedGames:yield w.savedGames.count(),vectorEntries:e?yield L(e):yield T(),memoryAnalytics:e?yield w.memoryAnalytics.where("gameId").equals(e).count():yield w.memoryAnalytics.count(),ragPerformance:e?yield w.ragPerformance.where("gameId").equals(e).count():yield w.ragPerformance.count(),aiMemoryChunks:e?yield w.aiMemoryChunks.where("gameId").equals(e).count():yield w.aiMemoryChunks.count(),semanticClusters:e?yield w.semanticClusters.where("gameId").equals(e).count():yield w.semanticClusters.count(),userInteractions:e?yield w.userInteractions.where("gameId").equals(e).count():yield w.userInteractions.count()}})},getGlobalSettings:k,getInteractionsByType:function(e,t){return u(this,null,function*(){return w.userInteractions.where("[gameId+interactionType]").equals([e,t]).toArray()})},getMemoriesByChunkType:function(e,t){return u(this,null,function*(){return w.aiMemoryChunks.where("[gameId+chunkType]").equals([e,t]).toArray()})},getMemoriesByTopic:function(e,t){return u(this,null,function*(){return w.aiMemoryChunks.where("[gameId+chunkType]").equals([e,"semantic"]).filter(e=>{var n,r,i;return null!=(i=null==(r=null==(n=e.metadata)?void 0:n.topics)?void 0:r.includes(t))&&i}).toArray()})},getMemoryAnalyticsByGameId:function(e){return u(this,null,function*(){return w.memoryAnalytics.where("gameId").equals(e).toArray()})},getMemoryAnalyticsByType:function(e,t){return u(this,null,function*(){return w.memoryAnalytics.where("[gameId+memoryType]").equals([e,t]).toArray()})},getOldestStoryHistoryEntriesForPruning:D,getRAGPerformanceByOperation:function(e,t){return u(this,null,function*(){return w.ragPerformance.where("[gameId+operationType]").equals([e,t]).toArray()})},getRAGPerformanceStats:function(e,t="week"){return u(this,null,function*(){const n=new Date,r=new Date;switch(t){case"day":r.setDate(n.getDate()-1);break;case"week":r.setDate(n.getDate()-7);break;case"month":r.setMonth(n.getMonth()-1)}return w.ragPerformance.where("gameId").equals(e).filter(e=>new Date(e.timestamp)>r).toArray()})},getSavedGame:v,getTopMemoriesByImportance:function(e,t=50){return u(this,null,function*(){return w.aiMemoryChunks.where("gameId").equals(e).reverse().sortBy("importance").then(e=>e.slice(0,t))})},getTrainingDatasetByGameId:function(e){return u(this,null,function*(){return w.trainingDatasets.get(e)})},getUserInteractions:function(e,t=100){return u(this,null,function*(){return w.userInteractions.where("gameId").equals(e).reverse().sortBy("timestamp").then(e=>e.slice(0,t))})},getVectorEntriesBatch:j,getVectorEntriesByGameId:S,getVectorEntriesByGameIdAndType:M,logRAGPerformance:function(e){return u(this,null,function*(){return w.ragPerformance.add(e)})},resetHardButKeepGlobalSettings:W,saveGlobalSettings:E,showDBError:O,trackUserInteraction:function(e){return u(this,null,function*(){return w.userInteractions.add(e)})},updateClusterStability:function(e,t){return u(this,null,function*(){const n=yield w.semanticClusters.get(e);n&&(n.stability=t,n.lastUpdated=(new Date).toISOString(),yield w.semanticClusters.put(n))})},updateMemoryAccess:function(e){return u(this,null,function*(){const t=yield w.aiMemoryChunks.get(e);t&&(t.accessCount++,t.lastAccessed=(new Date).toISOString(),t.updatedAt=(new Date).toISOString(),yield w.aiMemoryChunks.put(t))})},updateMemoryAnalytics:function(e,t){return u(this,null,function*(){const n=yield w.memoryAnalytics.get(e);if(n){const e=c(a(a({},n),t),{timestamp:(new Date).toISOString()});return w.memoryAnalytics.put(e)}return null})},upsertSavedGame:A},Symbol.toStringTag,{value:"Module"}));var F,B={exports:{}};var Q,V,J=function(){if(F)return B.exports;F=1;var e,t="object"==typeof Reflect?Reflect:null,n=t&&"function"==typeof t.apply?t.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};e=t&&"function"==typeof t.ownKeys?t.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var r=Number.isNaN||function(e){return e!=e};function i(){i.init.call(this)}B.exports=i,B.exports.once=function(e,t){return new Promise(function(n,r){function i(n){e.removeListener(t,o),r(n)}function o(){"function"==typeof e.removeListener&&e.removeListener("error",i),n([].slice.call(arguments))}g(e,t,o,{once:!0}),"error"!==t&&function(e,t,n){"function"==typeof e.on&&g(e,"error",t,n)}(e,i,{once:!0})})},i.EventEmitter=i,i.prototype._events=void 0,i.prototype._eventsCount=0,i.prototype._maxListeners=void 0;var o=10;function s(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function a(e){return void 0===e._maxListeners?i.defaultMaxListeners:e._maxListeners}function c(e,t,n,r){var i,o,c;if(s(n),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),o=e._events),c=o[t]),void 0===c)c=o[t]=n,++e._eventsCount;else if("function"==typeof c?c=o[t]=r?[n,c]:[c,n]:r?c.unshift(n):c.push(n),(i=a(e))>0&&c.length>i&&!c.warned){c.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+c.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=e,u.type=t,u.count=c.length,console&&console.warn}return e}function u(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function d(e,t,n){var r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=u.bind(r);return i.listener=n,r.wrapFn=i,i}function h(e,t,n){var r=e._events;if(void 0===r)return[];var i=r[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):p(i,i.length)}function l(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function p(e,t){for(var n=new Array(t),r=0;r<t;++r)n[r]=e[r];return n}function g(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,function i(o){r.once&&e.removeEventListener(t,i),n(o)})}}return Object.defineProperty(i,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(e){if("number"!=typeof e||e<0||r(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");o=e}}),i.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},i.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||r(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},i.prototype.getMaxListeners=function(){return a(this)},i.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var i="error"===e,o=this._events;if(void 0!==o)i=i&&void 0===o.error;else if(!i)return!1;if(i){var s;if(t.length>0&&(s=t[0]),s instanceof Error)throw s;var a=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw a.context=s,a}var c=o[e];if(void 0===c)return!1;if("function"==typeof c)n(c,this,t);else{var u=c.length,d=p(c,u);for(r=0;r<u;++r)n(d[r],this,t)}return!0},i.prototype.addListener=function(e,t){return c(this,e,t,!1)},i.prototype.on=i.prototype.addListener,i.prototype.prependListener=function(e,t){return c(this,e,t,!0)},i.prototype.once=function(e,t){return s(t),this.on(e,d(this,e,t)),this},i.prototype.prependOnceListener=function(e,t){return s(t),this.prependListener(e,d(this,e,t)),this},i.prototype.removeListener=function(e,t){var n,r,i,o,a;if(s(t),void 0===(r=this._events))return this;if(void 0===(n=r[e]))return this;if(n===t||n.listener===t)0===--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(i=-1,o=n.length-1;o>=0;o--)if(n[o]===t||n[o].listener===t){a=n[o].listener,i=o;break}if(i<0)return this;0===i?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,i),1===n.length&&(r[e]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",e,a||t)}return this},i.prototype.off=i.prototype.removeListener,i.prototype.removeAllListeners=function(e){var t,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0===--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var i,o=Object.keys(n);for(r=0;r<o.length;++r)"removeListener"!==(i=o[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(r=t.length-1;r>=0;r--)this.removeListener(e,t[r]);return this},i.prototype.listeners=function(e){return h(this,e,!0)},i.prototype.rawListeners=function(e){return h(this,e,!1)},i.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):l.call(e,t)},i.prototype.listenerCount=l,i.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]},B.exports}();function K(){if(V)return Q;function e(e){if("function"!=typeof e)throw new Error("obliterator/iterator: expecting a function!");this.next=e}return V=1,"undefined"!=typeof Symbol&&(e.prototype[Symbol.iterator]=function(){return this}),e.of=function(){var t=arguments,n=t.length,r=0;return new e(function(){return r>=n?{done:!0}:{done:!1,value:t[r++]}})},e.empty=function(){return new e(function(){return{done:!0}})},e.fromSequence=function(t){var n=0,r=t.length;return new e(function(){return n>=r?{done:!0}:{done:!1,value:t[n++]}})},e.is=function(t){return t instanceof e||"object"==typeof t&&null!==t&&"function"==typeof t.next},Q=e}const Y=f(K());var Z,X,ee,te,ne,re={};function ie(){return Z||(Z=1,re.ARRAY_BUFFER_SUPPORT="undefined"!=typeof ArrayBuffer,re.SYMBOL_SUPPORT="undefined"!=typeof Symbol),re}function oe(){if(ee)return X;ee=1;var e=K(),t=ie(),n=t.ARRAY_BUFFER_SUPPORT,r=t.SYMBOL_SUPPORT;return X=function(t){var i=function(t){return"string"==typeof t||Array.isArray(t)||n&&ArrayBuffer.isView(t)?e.fromSequence(t):"object"!=typeof t||null===t?null:r&&"function"==typeof t[Symbol.iterator]?t[Symbol.iterator]():"function"==typeof t.next?t:null}(t);if(!i)throw new Error("obliterator: target is not iterable nor a valid iterator.");return i}}const se=f(function(){if(ne)return te;ne=1;var e=oe();return te=function(t,n){for(var r,i=arguments.length>1?n:1/0,o=i!==1/0?new Array(i):[],s=0,a=e(t);;){if(s===i)return o;if((r=a.next()).done)return s!==n&&(o.length=s),o;o[s++]=r.value}}}());var ae,ce;const ue=f(function(){if(ce)return ae;ce=1;var e=K(),t=oe();return ae=function(){var n=arguments,r=null,i=-1;return new e(function(){for(var e=null;;){if(null===r){if(++i>=n.length)return{done:!0};r=t(n[i])}if(!0!==(e=r.next()).done)break;r=null}return e})}}());let de=function(){const e=arguments[0];for(let t=1,n=arguments.length;t<n;t++)if(arguments[t])for(const r in arguments[t])e[r]=arguments[t][r];return e};function he(e,t,n,r){const i=e._nodes.get(t);let o=null;return i?(o="mixed"===r?i.out&&i.out[n]||i.undirected&&i.undirected[n]:"directed"===r?i.out&&i.out[n]:i.undirected&&i.undirected[n],o):o}function le(e){return"object"==typeof e&&null!==e}function pe(e){let t;for(t in e)return!1;return!0}function ge(e,t,n){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:n})}function me(e,t,n){const r={enumerable:!0,configurable:!0};"function"==typeof n?r.get=n:(r.value=n,r.writable=!1),Object.defineProperty(e,t,r)}function fe(e){return!!le(e)&&!(e.attributes&&!Array.isArray(e.attributes))}"function"==typeof Object.assign&&(de=Object.assign);class ye extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class we extends ye{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,we.prototype.constructor)}}class be extends ye{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,be.prototype.constructor)}}class ve extends ye{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,ve.prototype.constructor)}}function Ae(e,t){this.key=e,this.attributes=t,this.clear()}function Ie(e,t){this.key=e,this.attributes=t,this.clear()}function ke(e,t){this.key=e,this.attributes=t,this.clear()}function Ee(e,t,n,r,i){this.key=t,this.attributes=i,this.undirected=e,this.source=n,this.target=r}Ae.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},Ie.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},ke.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},Ee.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");const n=this.source.key,r=this.target.key;this.source[e][r]=this,this.undirected&&n===r||(this.target[t][n]=this)},Ee.prototype.attachMulti=function(){let e="out",t="in";const n=this.source.key,r=this.target.key;this.undirected&&(e=t="undirected");const i=this.source[e],o=i[r];if(void 0===o)return i[r]=this,void(this.undirected&&n===r||(this.target[t][n]=this));o.previous=this,this.next=o,i[r]=this,this.target[t][n]=this},Ee.prototype.detach=function(){const e=this.source.key,t=this.target.key;let n="out",r="in";this.undirected&&(n=r="undirected"),delete this.source[n][t],delete this.target[r][e]},Ee.prototype.detachMulti=function(){const e=this.source.key,t=this.target.key;let n="out",r="in";this.undirected&&(n=r="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[n][t],delete this.target[r][e]):(this.next.previous=void 0,this.source[n][t]=this.next,this.target[r][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};function Se(e,t,n,r,i,o,s){let a,c,u,d;if(r=""+r,0===n){if(a=e._nodes.get(r),!a)throw new be(`Graph.${t}: could not find the "${r}" node in the graph.`);u=i,d=o}else if(3===n){if(i=""+i,c=e._edges.get(i),!c)throw new be(`Graph.${t}: could not find the "${i}" edge in the graph.`);const n=c.source.key,h=c.target.key;if(r===n)a=c.target;else{if(r!==h)throw new be(`Graph.${t}: the "${r}" node is not attached to the "${i}" edge (${n}, ${h}).`);a=c.source}u=o,d=s}else{if(c=e._edges.get(r),!c)throw new be(`Graph.${t}: could not find the "${r}" edge in the graph.`);a=1===n?c.source:c.target,u=i,d=o}return[a,u,d]}const xe=[{name:e=>`get${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Se(this,t,n,e,r,i);return o.attributes[s]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){const[i]=Se(this,t,n,e,r);return i.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Se(this,t,n,e,r,i);return o.attributes.hasOwnProperty(s)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i,o){const[s,a,c]=Se(this,t,n,e,r,i,o);return s.attributes[a]=c,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:a}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i,o){const[s,a,c]=Se(this,t,n,e,r,i,o);if("function"!=typeof c)throw new we(`Graph.${t}: updater should be a function.`);const u=s.attributes,d=c(u[a]);return u[a]=d,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:a}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Se(this,t,n,e,r,i);return delete o.attributes[s],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:s}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Se(this,t,n,e,r,i);if(!le(s))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=s,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Se(this,t,n,e,r,i);if(!le(s))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return de(o.attributes,s),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:s}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Se(this,t,n,e,r,i);if("function"!=typeof s)throw new we(`Graph.${t}: provided updater is not a function.`);return o.attributes=s(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}];const Ce=[{name:e=>`get${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=he(this,o,s,n),!i)throw new be(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return i.attributes[r]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e){let r;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const i=""+e,o=""+arguments[1];if(r=he(this,i,o,n),!r)throw new be(`Graph.${t}: could not find an edge for the given path ("${i}" - "${o}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return r.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=he(this,o,s,n),!i)throw new be(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return i.attributes.hasOwnProperty(r)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],i=arguments[3],o=he(this,s,a,n),!o)throw new be(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return o.attributes[r]=i,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],i=arguments[3],o=he(this,s,a,n),!o)throw new be(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof i)throw new we(`Graph.${t}: updater should be a function.`);return o.attributes[r]=i(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=he(this,o,s,n),!i)throw new be(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return delete i.attributes[r],this.emit("edgeAttributesUpdated",{key:i.key,type:"remove",attributes:i.attributes,name:r}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=he(this,o,s,n),!i)throw new be(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!le(r))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return i.attributes=r,this.emit("edgeAttributesUpdated",{key:i.key,type:"replace",attributes:i.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=he(this,o,s,n),!i)throw new be(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!le(r))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return de(i.attributes,r),this.emit("edgeAttributesUpdated",{key:i.key,type:"merge",attributes:i.attributes,data:r}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=he(this,o,s,n),!i)throw new be(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new be(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof r)throw new we(`Graph.${t}: provided updater is not a function.`);return i.attributes=r(i.attributes),this.emit("edgeAttributesUpdated",{key:i.key,type:"update",attributes:i.attributes}),this}}}];const Me=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function _e(e,t,n,r){let i=!1;for(const o in t){if(o===r)continue;const s=t[o];if(i=n(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),e&&i)return s.key}}function $e(e,t,n,r){let i,o,s,a=!1;for(const c in t)if(c!==r){i=t[c];do{if(o=i.source,s=i.target,a=n(i.key,i.attributes,o.key,s.key,o.attributes,s.attributes,i.undirected),e&&a)return i.key;i=i.next}while(void 0!==i)}}function De(e,t){const n=Object.keys(e),r=n.length;let i,o=0;return new Y(function(){do{if(i)i=i.next;else{if(o>=r)return{done:!0};const s=n[o++];if(s===t){i=void 0;continue}i=e[s]}}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}})}function Ge(e,t,n,r){const i=t[n];if(!i)return;const o=i.source,s=i.target;return r(i.key,i.attributes,o.key,s.key,o.attributes,s.attributes,i.undirected)&&e?i.key:void 0}function Le(e,t,n,r){let i=t[n];if(!i)return;let o=!1;do{if(o=r(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected),e&&o)return i.key;i=i.next}while(void 0!==i)}function Ne(e,t){let n=e[t];return void 0!==n.next?new Y(function(){if(!n)return{done:!0};const e={edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected};return n=n.next,{done:!1,value:e}}):Y.of({edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected})}function Te(e,t,n,r){if(0===t.size)return;const i="mixed"!==n&&n!==t.type,o="undirected"===n;let s,a,c=!1;const u=t._edges.values();for(;s=u.next(),!0!==s.done;){if(a=s.value,i&&a.undirected!==o)continue;const{key:t,attributes:n,source:u,target:d}=a;if(c=r(t,n,u.key,d.key,u.attributes,d.attributes,a.undirected),e&&c)return t}}function je(e,t,n,r,i,o){const s=t?$e:_e;let a;if("undirected"!==n){if("out"!==r&&(a=s(e,i.in,o),e&&a))return a;if("in"!==r&&(a=s(e,i.out,o,r?void 0:i.key),e&&a))return a}if("directed"!==n&&(a=s(e,i.undirected,o),e&&a))return a}function Oe(e,t,n,r,i,o,s){const a=n?Le:Ge;let c;if("undirected"!==t){if(void 0!==i.in&&"out"!==r&&(c=a(e,i.in,o,s),e&&c))return c;if(void 0!==i.out&&"in"!==r&&(r||i.key!==o)&&(c=a(e,i.out,o,s),e&&c))return c}if("directed"!==t&&void 0!==i.undirected&&(c=a(e,i.undirected,o,s),e&&c))return c}function ze(e,t){const{name:n,type:r,direction:i}=t;e.prototype[n]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(!arguments.length)return function(e,t){if(0===e.size)return[];if("mixed"===t||t===e.type)return"function"==typeof Array.from?Array.from(e._edges.keys()):se(e._edges.keys(),e._edges.size);const n="undirected"===t?e.undirectedSize:e.directedSize,r=new Array(n),i="undirected"===t,o=e._edges.values();let s,a,c=0;for(;s=o.next(),!0!==s.done;)a=s.value,a.undirected===i&&(r[c++]=a.key);return r}(this,r);if(1===arguments.length){e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new be(`Graph.${n}: could not find the "${e}" node in the graph.`);return function(e,t,n,r){const i=[];return je(!1,e,t,n,r,function(e){i.push(e)}),i}(this.multi,"mixed"===r?this.type:r,i,t)}if(2===arguments.length){e=""+e,t=""+t;const o=this._nodes.get(e);if(!o)throw new be(`Graph.${n}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.${n}:  could not find the "${t}" target node in the graph.`);return function(e,t,n,r,i){const o=[];return Oe(!1,e,t,n,r,i,function(e){o.push(e)}),o}(r,this.multi,i,o,t)}throw new we(`Graph.${n}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Pe(e,t){const{name:n,type:r,direction:i}=t,o=n.slice(0,-1)+"Entries";e.prototype[o]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return Y.empty();if(!arguments.length)return function(e,t){if(0===e.size)return Y.empty();const n="mixed"!==t&&t!==e.type,r="undirected"===t,i=e._edges.values();return new Y(function(){let e,t;for(;;){if(e=i.next(),e.done)return e;if(t=e.value,!n||t.undirected===r)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}})}(this,r);if(1===arguments.length){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.${o}: could not find the "${e}" node in the graph.`);return function(e,t,n){let r=Y.empty();return"undirected"!==e&&("out"!==t&&void 0!==n.in&&(r=ue(r,De(n.in))),"in"!==t&&void 0!==n.out&&(r=ue(r,De(n.out,t?void 0:n.key)))),"directed"!==e&&void 0!==n.undirected&&(r=ue(r,De(n.undirected))),r}(r,i,t)}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return function(e,t,n,r){let i=Y.empty();return"undirected"!==e&&(void 0!==n.in&&"out"!==t&&r in n.in&&(i=ue(i,Ne(n.in,r))),void 0!==n.out&&"in"!==t&&r in n.out&&(t||n.key!==r)&&(i=ue(i,Ne(n.out,r)))),"directed"!==e&&void 0!==n.undirected&&r in n.undirected&&(i=ue(i,Ne(n.undirected,r))),i}(r,i,n,t)}throw new we(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}const Ue=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function We(){this.A=null,this.B=null}function qe(e,t,n,r,i){for(const o in r){const s=r[o],a=s.source,c=s.target,u=a===n?c:a;if(t&&t.has(u.key))continue;const d=i(u.key,u.attributes);if(e&&d)return u.key}}function Re(e,t,n,r,i){if("mixed"!==t){if("undirected"===t)return qe(e,null,r,r.undirected,i);if("string"==typeof n)return qe(e,null,r,r[n],i)}const o=new We;let s;if("undirected"!==t){if("out"!==n){if(s=qe(e,null,r,r.in,i),e&&s)return s;o.wrap(r.in)}if("in"!==n){if(s=qe(e,o,r,r.out,i),e&&s)return s;o.wrap(r.out)}}if("directed"!==t&&(s=qe(e,o,r,r.undirected,i),e&&s))return s}function He(e,t,n){const r=Object.keys(n),i=r.length;let o=0;return new Y(function(){let s=null;do{if(o>=i)return e&&e.wrap(n),{done:!0};const a=n[r[o++]],c=a.source,u=a.target;s=c===t?u:c,e&&e.has(s.key)&&(s=null)}while(null===s);return{done:!1,value:{neighbor:s.key,attributes:s.attributes}}})}function Fe(e,t){const{name:n,type:r,direction:i}=t;e.prototype[n]=function(e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new be(`Graph.${n}: could not find the "${e}" node in the graph.`);return function(e,t,n){if("mixed"!==e){if("undirected"===e)return Object.keys(n.undirected);if("string"==typeof t)return Object.keys(n[t])}const r=[];return Re(!1,e,t,n,function(e){r.push(e)}),r}("mixed"===r?this.type:r,i,t)}}function Be(e,t){const{name:n,type:r,direction:i}=t,o=n.slice(0,-1)+"Entries";e.prototype[o]=function(e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return Y.empty();e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new be(`Graph.${o}: could not find the "${e}" node in the graph.`);return function(e,t,n){if("mixed"!==e){if("undirected"===e)return He(null,n,n.undirected);if("string"==typeof t)return He(null,n,n[t])}let r=Y.empty();const i=new We;return"undirected"!==e&&("out"!==t&&(r=ue(r,He(i,n,n.in))),"in"!==t&&(r=ue(r,He(i,n,n.out)))),"directed"!==e&&(r=ue(r,He(i,n,n.undirected))),r}("mixed"===r?this.type:r,i,t)}}function Qe(e,t,n,r,i){const o=r._nodes.values(),s=r.type;let a,c,u,d,h,l;for(;a=o.next(),!0!==a.done;){let e=!1;if(c=a.value,"undirected"!==s)for(u in d=c.out,d){h=d[u];do{l=h.target,e=!0,i(c.key,l.key,c.attributes,l.attributes,h.key,h.attributes,h.undirected),h=h.next}while(h)}if("directed"!==s)for(u in d=c.undirected,d)if(!(t&&c.key>u)){h=d[u];do{l=h.target,l.key!==u&&(l=h.source),e=!0,i(c.key,l.key,c.attributes,l.attributes,h.key,h.attributes,h.undirected),h=h.next}while(h)}n&&!e&&i(c.key,null,c.attributes,null,null,null,null)}}function Ve(e){if(!le(e))throw new we('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in e))throw new we("Graph.import: serialized node is missing its key.");if("attributes"in e&&(!le(e.attributes)||null===e.attributes))throw new we("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Je(e){if(!le(e))throw new we('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in e))throw new we("Graph.import: serialized edge is missing its source.");if(!("target"in e))throw new we("Graph.import: serialized edge is missing its target.");if("attributes"in e&&(!le(e.attributes)||null===e.attributes))throw new we("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in e&&"boolean"!=typeof e.undirected)throw new we("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}We.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},We.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};const Ke=function(){let e=255&Math.floor(256*Math.random());return()=>e++}(),Ye=new Set(["directed","undirected","mixed"]),Ze=new Set(["domain","_events","_eventsCount","_maxListeners"]),Xe={allowSelfLoops:!0,multi:!1,type:"mixed"};function et(e,t,n){const r=new e.NodeDataClass(t,n);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:n}),r}function tt(e,t,n,r,i,o,s,a){if(!r&&"undirected"===e.type)throw new ve(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&"directed"===e.type)throw new ve(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!le(a))throw new we(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,s=""+s,a=a||{},!e.allowSelfLoops&&o===s)throw new ve(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const c=e._nodes.get(o),u=e._nodes.get(s);if(!c)throw new be(`Graph.${t}: source node "${o}" not found.`);if(!u)throw new be(`Graph.${t}: target node "${s}" not found.`);const d={key:null,undirected:r,source:o,target:s,attributes:a};if(n)i=e._edgeKeyGenerator();else if(i=""+i,e._edges.has(i))throw new ve(`Graph.${t}: the "${i}" edge already exists in the graph.`);if(!e.multi&&(r?void 0!==c.undirected[s]:void 0!==c.out[s]))throw new ve(`Graph.${t}: an edge linking "${o}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const h=new Ee(r,i,c,u,a);e._edges.set(i,h);const l=o===s;return r?(c.undirectedDegree++,u.undirectedDegree++,l&&(c.undirectedLoops++,e._undirectedSelfLoopCount++)):(c.outDegree++,u.inDegree++,l&&(c.directedLoops++,e._directedSelfLoopCount++)),e.multi?h.attachMulti():h.attach(),r?e._undirectedSize++:e._directedSize++,d.key=i,e.emit("edgeAdded",d),i}function nt(e,t,n,r,i,o,s,a,c){if(!r&&"undirected"===e.type)throw new ve(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&"directed"===e.type)throw new ve(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a)if(c){if("function"!=typeof a)throw new we(`Graph.${t}: invalid updater function. Expecting a function but got "${a}"`)}else if(!le(a))throw new we(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);let u;if(o=""+o,s=""+s,c&&(u=a,a=void 0),!e.allowSelfLoops&&o===s)throw new ve(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let d,h,l=e._nodes.get(o),p=e._nodes.get(s);if(!n&&(d=e._edges.get(i),d)){if(!(d.source.key===o&&d.target.key===s||r&&d.source.key===s&&d.target.key===o))throw new ve(`Graph.${t}: inconsistency detected when attempting to merge the "${i}" edge with "${o}" source & "${s}" target vs. ("${d.source.key}", "${d.target.key}").`);h=d}if(h||e.multi||!l||(h=r?l.undirected[s]:l.out[s]),h){const t=[h.key,!1,!1,!1];if(c?!u:!a)return t;if(c){const t=h.attributes;h.attributes=u(t),e.emit("edgeAttributesUpdated",{type:"replace",key:h.key,attributes:h.attributes})}else de(h.attributes,a),e.emit("edgeAttributesUpdated",{type:"merge",key:h.key,attributes:h.attributes,data:a});return t}a=a||{},c&&u&&(a=u(a));const g={key:null,undirected:r,source:o,target:s,attributes:a};if(n)i=e._edgeKeyGenerator();else if(i=""+i,e._edges.has(i))throw new ve(`Graph.${t}: the "${i}" edge already exists in the graph.`);let m=!1,f=!1;l||(l=et(e,o,{}),m=!0,o===s&&(p=l,f=!0)),p||(p=et(e,s,{}),f=!0),d=new Ee(r,i,l,p,a),e._edges.set(i,d);const y=o===s;return r?(l.undirectedDegree++,p.undirectedDegree++,y&&(l.undirectedLoops++,e._undirectedSelfLoopCount++)):(l.outDegree++,p.inDegree++,y&&(l.directedLoops++,e._directedSelfLoopCount++)),e.multi?d.attachMulti():d.attach(),r?e._undirectedSize++:e._directedSize++,g.key=i,e.emit("edgeAdded",g),[i,!0,m,f]}function rt(e,t){e._edges.delete(t.key);const{source:n,target:r,attributes:i}=t,o=t.undirected,s=n===r;o?(n.undirectedDegree--,r.undirectedDegree--,s&&(n.undirectedLoops--,e._undirectedSelfLoopCount--)):(n.outDegree--,r.inDegree--,s&&(n.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:i,source:n.key,target:r.key,undirected:o})}class it extends J.EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=de({},Xe,e)).multi)throw new we(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!Ye.has(e.type))throw new we(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new we(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);ge(this,"NodeDataClass","mixed"===e.type?Ae:"directed"===e.type?Ie:ke);const t="geid_"+Ke()+"_";let n=0;ge(this,"_attributes",{}),ge(this,"_nodes",new Map),ge(this,"_edges",new Map),ge(this,"_directedSize",0),ge(this,"_undirectedSize",0),ge(this,"_directedSelfLoopCount",0),ge(this,"_undirectedSelfLoopCount",0),ge(this,"_edgeKeyGenerator",()=>{let e;do{e=t+n++}while(this._edges.has(e));return e}),ge(this,"_options",e),Ze.forEach(e=>ge(this,e,this[e])),me(this,"order",()=>this._nodes.size),me(this,"size",()=>this._edges.size),me(this,"directedSize",()=>this._directedSize),me(this,"undirectedSize",()=>this._undirectedSize),me(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),me(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),me(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),me(this,"multi",this._options.multi),me(this,"type",this._options.type),me(this,"allowSelfLoops",this._options.allowSelfLoops),me(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){const t=""+e,n=this._edges.get(t);return!!n&&!n.undirected}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);return!!n&&n.out.hasOwnProperty(t)}throw new we(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1===arguments.length){const t=""+e,n=this._edges.get(t);return!!n&&n.undirected}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);return!!n&&n.undirected.hasOwnProperty(t)}throw new we(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(1===arguments.length){const t=""+e;return this._edges.has(t)}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);return!!n&&(void 0!==n.out&&n.out.hasOwnProperty(t)||void 0!==n.undirected&&n.undirected.hasOwnProperty(t))}throw new we(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new ve("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const n=this._nodes.get(e);if(!n)throw new be(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const r=n.out&&n.out[t]||void 0;return r?r.key:void 0}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new ve("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const n=this._nodes.get(e);if(!n)throw new be(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const r=n.undirected&&n.undirected[t]||void 0;return r?r.key:void 0}edge(e,t){if(this.multi)throw new ve("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.edge: could not find the "${t}" target node in the graph.`);const r=n.out&&n.out[t]||n.undirected&&n.undirected[t]||void 0;if(r)return r.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in n.in||t in n.out)}areOutNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.out}areInNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in n.undirected}areNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in n.in||t in n.out)||"directed"!==this.type&&t in n.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.in||"directed"!==this.type&&t in n.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new be(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.out||"directed"!==this.type&&t in n.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.inDegree),n}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.outDegree),n}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.degree: could not find the "${e}" node in the graph.`);let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.inDegree+t.outDegree),n}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return"directed"!==this.type&&(n+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.inDegree,r+=t.directedLoops),n-r}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return"directed"!==this.type&&(n+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.outDegree,r+=t.directedLoops),n-r}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return"directed"!==this.type&&(n+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.inDegree+t.outDegree,r+=2*t.directedLoops),n-r}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new be(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new be(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new be(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const n=this._edges.get(t);if(!n)throw new be(`Graph.opposite: could not find the "${t}" edge in the graph.`);const r=n.source.key,i=n.target.key;if(e===r)return i;if(e===i)return r;throw new be(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${r}, ${i}).`)}hasExtremity(e,t){e=""+e,t=""+t;const n=this._edges.get(e);if(!n)throw new be(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return n.source.key===t||n.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new be(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new be(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new be(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){const n=function(e,t,n){if(n&&!le(n))throw new we(`Graph.addNode: invalid attributes. Expecting an object but got "${n}"`);if(t=""+t,n=n||{},e._nodes.has(t))throw new ve(`Graph.addNode: the "${t}" node already exist in the graph.`);const r=new e.NodeDataClass(t,n);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:n}),r}(this,e,t);return n.key}mergeNode(e,t){if(t&&!le(t))throw new we(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let n=this._nodes.get(e);return n?(t&&(de(n.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:n.attributes,data:t})),[e,!1]):(n=new this.NodeDataClass(e,t),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new we(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let n=this._nodes.get(e);if(n){if(t){const r=n.attributes;n.attributes=t(r),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:n.attributes})}return[e,!1]}const r=t?t({}):{};return n=new this.NodeDataClass(e,r),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:r}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new be(`Graph.dropNode: could not find the "${e}" node in the graph.`);let n;if("undirected"!==this.type){for(const e in t.out){n=t.out[e];do{rt(this,n),n=n.next}while(n)}for(const e in t.in){n=t.in[e];do{rt(this,n),n=n.next}while(n)}}if("directed"!==this.type)for(const r in t.undirected){n=t.undirected[r];do{rt(this,n),n=n.next}while(n)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const e=""+arguments[0],n=""+arguments[1];if(t=he(this,e,n,this.type),!t)throw new be(`Graph.dropEdge: could not find the "${e}" -> "${n}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new be(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return rt(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new ve("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new ve("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=he(this,e=""+e,t=""+t,"directed");if(!n)throw new be(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return rt(this,n),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new ve("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new ve("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=he(this,e,t,"undirected");if(!n)throw new be(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return rt(this,n),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),!0!==t.done;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new we("Graph.updateAttribute: updater should be a function.");const n=this._attributes[e];return this._attributes[e]=t(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!le(e))throw new we("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!le(e))throw new we("Graph.mergeAttributes: provided attributes are not a plain object.");return de(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new we("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if("function"!=typeof e)throw new we("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!fe(t))throw new we("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._nodes.values();let r,i;for(;r=n.next(),!0!==r.done;)i=r.value,i.attributes=e(i.key,i.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if("function"!=typeof e)throw new we("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!fe(t))throw new we("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._edges.values();let r,i,o,s;for(;r=n.next(),!0!==r.done;)i=r.value,o=i.source,s=i.target,i.attributes=e(i.key,i.attributes,o.key,s.key,o.attributes,s.attributes,i.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new we("Graph.forEachAdjacencyEntry: expecting a callback.");Qe(0,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new we("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Qe(0,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new we("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Qe(0,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new we("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Qe(0,!0,!0,this,e)}nodes(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):se(this._nodes.keys(),this._nodes.size)}forEachNode(e){if("function"!=typeof e)throw new we("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)r=n.value,e(r.key,r.attributes)}findNode(e){if("function"!=typeof e)throw new we("Graph.findNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)if(r=n.value,e(r.key,r.attributes))return r.key}mapNodes(e){if("function"!=typeof e)throw new we("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let n,r;const i=new Array(this.order);let o=0;for(;n=t.next(),!0!==n.done;)r=n.value,i[o++]=e(r.key,r.attributes);return i}someNode(e){if("function"!=typeof e)throw new we("Graph.someNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)if(r=n.value,e(r.key,r.attributes))return!0;return!1}everyNode(e){if("function"!=typeof e)throw new we("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)if(r=n.value,!e(r.key,r.attributes))return!1;return!0}filterNodes(e){if("function"!=typeof e)throw new we("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let n,r;const i=[];for(;n=t.next(),!0!==n.done;)r=n.value,e(r.key,r.attributes)&&i.push(r.key);return i}reduceNodes(e,t){if("function"!=typeof e)throw new we("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new we("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=t;const r=this._nodes.values();let i,o;for(;i=r.next(),!0!==i.done;)o=i.value,n=e(n,o.key,o.attributes);return n}nodeEntries(){const e=this._nodes.values();return new Y(()=>{const t=e.next();if(t.done)return t;const n=t.value;return{value:{node:n.key,attributes:n.attributes},done:!1}})}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((n,r)=>{e[t++]=function(e,t){const n={key:e};return pe(t.attributes)||(n.attributes=de({},t.attributes)),n}(r,n)});const n=new Array(this._edges.size);return t=0,this._edges.forEach((e,r)=>{n[t++]=function(e,t,n){const r={key:t,source:n.source.key,target:n.target.key};return pe(n.attributes)||(r.attributes=de({},n.attributes)),"mixed"===e&&n.undirected&&(r.undirected=!0),r}(this.type,r,e)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:n}}import(e,t=!1){if(e instanceof it)return e.forEachNode((e,n)=>{t?this.mergeNode(e,n):this.addNode(e,n)}),e.forEachEdge((e,n,r,i,o,s,a)=>{t?a?this.mergeUndirectedEdgeWithKey(e,r,i,n):this.mergeDirectedEdgeWithKey(e,r,i,n):a?this.addUndirectedEdgeWithKey(e,r,i,n):this.addDirectedEdgeWithKey(e,r,i,n)}),this;if(!le(e))throw new we("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!le(e.attributes))throw new we("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let n,r,i,o,s;if(e.nodes){if(i=e.nodes,!Array.isArray(i))throw new we("Graph.import: invalid nodes. Expecting an array.");for(n=0,r=i.length;n<r;n++){o=i[n],Ve(o);const{key:e,attributes:r}=o;t?this.mergeNode(e,r):this.addNode(e,r)}}if(e.edges){let o=!1;if("undirected"===this.type&&(o=!0),i=e.edges,!Array.isArray(i))throw new we("Graph.import: invalid edges. Expecting an array.");for(n=0,r=i.length;n<r;n++){s=i[n],Je(s);const{source:e,target:r,attributes:a,undirected:c=o}=s;let u;"key"in s?(u=t?c?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:c?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,u.call(this,s.key,e,r,a)):(u=t?c?this.mergeUndirectedEdge:this.mergeDirectedEdge:c?this.addUndirectedEdge:this.addDirectedEdge,u.call(this,e,r,a))}}return this}nullCopy(e){const t=new it(de({},this._options,e));return t.replaceAttributes(de({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((e,n)=>{const r=de({},e.attributes);e=new t.NodeDataClass(n,r),t._nodes.set(n,e)}),t}copy(e){if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new ve(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new ve("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new ve("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),n=this._edges.values();let r,i;for(;r=n.next(),!0!==r.done;)i=r.value,tt(t,"copy",!1,i.undirected,i.key,i.source.key,i.target.key,de({},i.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((t,n)=>{e[n]=t.attributes});const t={},n={};this._edges.forEach((e,r)=>{const i=e.undirected?"--":"->";let o,s="",a=e.source.key,c=e.target.key;e.undirected&&a>c&&(o=a,a=c,c=o);const u=`(${a})${i}(${c})`;r.startsWith("geid_")?this.multi&&(void 0===n[u]?n[u]=0:n[u]++,s+=`${n[u]}. `):s+=`[${r}]: `,s+=u,t[s]=e.attributes});const r={};for(const i in this)this.hasOwnProperty(i)&&!Ze.has(i)&&"function"!=typeof this[i]&&"symbol"!=typeof i&&(r[i]=this[i]);return r.attributes=this._attributes,r.nodes=e,r.edges=t,ge(r,"constructor",this.constructor),r}}var ot,st,at,ct,ut;"undefined"!=typeof Symbol&&(it.prototype[Symbol.for("nodejs.util.inspect.custom")]=it.prototype.inspect),[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}].forEach(e=>{["add","merge","update"].forEach(t=>{const n=e.name(t),r="add"===t?tt:nt;e.generateKey?it.prototype[n]=function(i,o,s){return r(this,n,!0,"undirected"===(e.type||this.type),null,i,o,s,"update"===t)}:it.prototype[n]=function(i,o,s,a){return r(this,n,!1,"undirected"===(e.type||this.type),i,o,s,a,"update"===t)}})}),ot=it,xe.forEach(function({name:e,attacher:t}){t(ot,e("Node"),0),t(ot,e("Source"),1),t(ot,e("Target"),2),t(ot,e("Opposite"),3)}),function(e){Ce.forEach(function({name:t,attacher:n}){n(e,t("Edge"),"mixed"),n(e,t("DirectedEdge"),"directed"),n(e,t("UndirectedEdge"),"undirected")})}(it),function(e){Me.forEach(t=>{ze(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t,n){if("mixed"===r||"mixed"===this.type||r===this.type){if(1===arguments.length)return Te(!1,this,r,n=e);if(2===arguments.length){e=""+e,n=t;const s=this._nodes.get(e);if(void 0===s)throw new be(`Graph.${o}: could not find the "${e}" node in the graph.`);return je(!1,this.multi,"mixed"===r?this.type:r,i,s,n)}if(3===arguments.length){e=""+e,t=""+t;const s=this._nodes.get(e);if(!s)throw new be(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return Oe(!1,r,this.multi,i,s,t,n)}throw new we(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+n[0].toUpperCase()+n.slice(1);e.prototype[s]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();let n;if(0===e.length){let i=0;"directed"!==r&&(i+=this.undirectedSize),"undirected"!==r&&(i+=this.directedSize),n=new Array(i);let o=0;e.push((e,r,i,s,a,c,u)=>{n[o++]=t(e,r,i,s,a,c,u)})}else n=[],e.push((e,r,i,o,s,a,c)=>{n.push(t(e,r,i,o,s,a,c))});return this[o].apply(this,e),n};const a="filter"+n[0].toUpperCase()+n.slice(1);e.prototype[a]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop(),n=[];return e.push((e,r,i,o,s,a,c)=>{t(e,r,i,o,s,a,c)&&n.push(e)}),this[o].apply(this,e),n};const c="reduce"+n[0].toUpperCase()+n.slice(1);e.prototype[c]=function(){let e,t,n=Array.prototype.slice.call(arguments);if(n.length<2||n.length>4)throw new we(`Graph.${c}: invalid number of arguments (expecting 2, 3 or 4 and got ${n.length}).`);if("function"==typeof n[n.length-1]&&"function"!=typeof n[n.length-2])throw new we(`Graph.${c}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);2===n.length?(e=n[0],t=n[1],n=[]):3===n.length?(e=n[1],t=n[2],n=[n[0]]):4===n.length&&(e=n[2],t=n[3],n=[n[0],n[1]]);let r=t;return n.push((t,n,i,o,s,a,c)=>{r=e(r,t,n,i,o,s,a,c)}),this[o].apply(this,n),r}}(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o="find"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t,n){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return!1;if(1===arguments.length)return Te(!0,this,r,n=e);if(2===arguments.length){e=""+e,n=t;const s=this._nodes.get(e);if(void 0===s)throw new be(`Graph.${o}: could not find the "${e}" node in the graph.`);return je(!0,this.multi,"mixed"===r?this.type:r,i,s,n)}if(3===arguments.length){e=""+e,t=""+t;const s=this._nodes.get(e);if(!s)throw new be(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new be(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return Oe(!0,r,this.multi,i,s,t,n)}throw new we(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[s]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,n,r,i,o,s,a)=>t(e,n,r,i,o,s,a)),!!this[o].apply(this,e)};const a="every"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[a]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,n,r,i,o,s,a)=>!t(e,n,r,i,o,s,a)),!this[o].apply(this,e)}}(e,t),Pe(e,t)})}(it),function(e){Ue.forEach(t=>{Fe(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return;e=""+e;const n=this._nodes.get(e);if(void 0===n)throw new be(`Graph.${o}: could not find the "${e}" node in the graph.`);Re(!1,"mixed"===r?this.type:r,i,n,t)};const s="map"+n[0].toUpperCase()+n.slice(1);e.prototype[s]=function(e,t){const n=[];return this[o](e,(e,r)=>{n.push(t(e,r))}),n};const a="filter"+n[0].toUpperCase()+n.slice(1);e.prototype[a]=function(e,t){const n=[];return this[o](e,(e,r)=>{t(e,r)&&n.push(e)}),n};const c="reduce"+n[0].toUpperCase()+n.slice(1);e.prototype[c]=function(e,t,n){if(arguments.length<3)throw new we(`Graph.${c}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let r=n;return this[o](e,(e,n)=>{r=t(r,e,n)}),r}}(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o=n[0].toUpperCase()+n.slice(1,-1),s="find"+o;e.prototype[s]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return;e=""+e;const n=this._nodes.get(e);if(void 0===n)throw new be(`Graph.${s}: could not find the "${e}" node in the graph.`);return Re(!0,"mixed"===r?this.type:r,i,n,t)};const a="some"+o;e.prototype[a]=function(e,t){return!!this[s](e,t)};const c="every"+o;e.prototype[c]=function(e,t){return!this[s](e,(e,n)=>!t(e,n))}}(e,t),Be(e,t)})}(it);class dt extends it{constructor(e){const t=de({type:"directed"},e);if("multi"in t&&!1!==t.multi)throw new we("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==t.type)throw new we('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class ht extends it{constructor(e){const t=de({type:"undirected"},e);if("multi"in t&&!1!==t.multi)throw new we("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new we('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class lt extends it{constructor(e){const t=de({multi:!0},e);if("multi"in t&&!0!==t.multi)throw new we("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class pt extends it{constructor(e){const t=de({type:"directed",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new we("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==t.type)throw new we('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class gt extends it{constructor(e){const t=de({type:"undirected",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new we("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new we('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function mt(e){e.from=function(t,n){const r=de({},t.options,n),i=new e(r);return i.import(t),i}}function ft(){return at?st:(at=1,st=function(e){return null!==e&&"object"==typeof e&&"function"==typeof e.addUndirectedEdgeWithKey&&"function"==typeof e.dropNode&&"boolean"==typeof e.multi})}function yt(){if(ut)return ct;function e(e){return!e||"object"!=typeof e||"function"==typeof e||Array.isArray(e)||e instanceof Set||e instanceof Map||e instanceof RegExp||e instanceof Date}return ut=1,ct=function t(n,r){n=n||{};var i={};for(var o in r){var s=n[o],a=r[o];e(a)?i[o]=void 0===s?a:s:i[o]=t(s,a)}return i},ct}mt(it),mt(dt),mt(ht),mt(lt),mt(pt),mt(gt),it.Graph=it,it.DirectedGraph=dt,it.UndirectedGraph=ht,it.MultiGraph=lt,it.MultiDirectedGraph=pt,it.MultiUndirectedGraph=gt,it.InvalidArgumentsGraphError=we,it.NotFoundGraphError=be,it.UsageGraphError=ve;var wt,bt={},vt={};function At(){return wt||(wt=1,function(e){var t=Math.pow(2,8)-1,n=Math.pow(2,16)-1,r=Math.pow(2,32)-1,i=Math.pow(2,7)-1,o=Math.pow(2,15)-1,s=Math.pow(2,31)-1;e.getPointerArray=function(e){var i=e-1;if(i<=t)return Uint8Array;if(i<=n)return Uint16Array;if(i<=r)return Uint32Array;throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.")},e.getSignedPointerArray=function(e){var t=e-1;return t<=i?Int8Array:t<=o?Int16Array:t<=s?Int32Array:Float64Array},e.getNumberType=function(e){return e===(0|e)?-1===Math.sign(e)?e<=127&&e>=-128?Int8Array:e<=32767&&e>=-32768?Int16Array:Int32Array:e<=255?Uint8Array:e<=65535?Uint16Array:Uint32Array:Float64Array};var a={Uint8Array:1,Int8Array:2,Uint16Array:3,Int16Array:4,Uint32Array:5,Int32Array:6,Float32Array:7,Float64Array:8};e.getMinimalRepresentation=function(t,n){var r,i,o,s,c,u=null,d=0;for(s=0,c=t.length;s<c;s++)o=n?n(t[s]):t[s],i=e.getNumberType(o),(r=a[i.name])>d&&(d=r,u=i);return u},e.isTypedArray=function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView(e)},e.concat=function(){var e,t,n,r=0;for(e=0,n=arguments.length;e<n;e++)r+=arguments[e].length;var i=new arguments[0].constructor(r);for(e=0,t=0;e<n;e++)i.set(arguments[e],t),t+=arguments[e].length;return i},e.indices=function(t){for(var n=new(e.getPointerArray(t))(t),r=0;r<t;r++)n[r]=r;return n}}(vt)),vt}var It,kt,Et,St,xt={};function Ct(){if(It)return xt;function e(e){return"number"!=typeof e||isNaN(e)?1:e}function t(e,t){var n={},r=function(e){return void 0===e?t:e};"function"==typeof t&&(r=t);var i=function(t){return r(t[e])},o=function(){return r(void 0)};return"string"==typeof e?(n.fromAttributes=i,n.fromGraph=function(e,t){return i(e.getEdgeAttributes(t))},n.fromEntry=function(e,t){return i(t)},n.fromPartialEntry=n.fromEntry,n.fromMinimalEntry=n.fromEntry):"function"==typeof e?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},n.fromGraph=function(t,n){var i=t.extremities(n);return r(e(n,t.getEdgeAttributes(n),i[0],i[1],t.getNodeAttributes(i[0]),t.getNodeAttributes(i[1]),t.isUndirected(n)))},n.fromEntry=function(t,n,i,o,s,a,c){return r(e(t,n,i,o,s,a,c))},n.fromPartialEntry=function(t,n,i,o){return r(e(t,n,i,o))},n.fromMinimalEntry=function(t,n){return r(e(t,n))}):(n.fromAttributes=o,n.fromGraph=o,n.fromEntry=o,n.fromMinimalEntry=o),n}return It=1,xt.createNodeValueGetter=function(e,t){var n={},r=function(e){return void 0===e?t:e};"function"==typeof t&&(r=t);var i=function(t){return r(t[e])},o=function(){return r(void 0)};return"string"==typeof e?(n.fromAttributes=i,n.fromGraph=function(e,t){return i(e.getNodeAttributes(t))},n.fromEntry=function(e,t){return i(t)}):"function"==typeof e?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createNodeValueGetter: irrelevant usage.")},n.fromGraph=function(t,n){return r(e(n,t.getNodeAttributes(n)))},n.fromEntry=function(t,n){return r(e(t,n))}):(n.fromAttributes=o,n.fromGraph=o,n.fromEntry=o),n},xt.createEdgeValueGetter=t,xt.createEdgeWeightGetter=function(n){return t(n,e)},xt}function Mt(){if(kt)return bt;kt=1;var e=At(),t=Ct().createEdgeWeightGetter;function n(e,t){return"outbound"===e||"inbound"===e?t.directedSize+2*t.undirectedSize:"in"===e||"out"===e||"directed"===e?t.directedSize:2*t.undirectedSize}function r(t,r){var i=t[(r=r||"outbound")+"Neighbors"].bind(t),o=n(r,t),s=e.getPointerArray(o),a=e.getPointerArray(t.order);this.graph=t,this.neighborhood=new a(o),this.starts=new s(t.order+1),this.nodes=t.nodes();var c,u,d,h,l,p={},g=0;for(c=0,u=t.order;c<u;c++)p[this.nodes[c]]=c;for(c=0,u=t.order;c<u;c++)for(l=i(this.nodes[c]),this.starts[c]=g,d=0,h=l.length;d<h;d++)this.neighborhood[g++]=p[l[d]];this.starts[c]=o}function i(r,i,o){var s=r[(o=o||"outbound")+"Edges"].bind(r),a=n(o,r),c=e.getPointerArray(a),u=e.getPointerArray(r.order),d=t(i).fromMinimalEntry;this.graph=r,this.neighborhood=new u(a),this.weights=new Float64Array(a),this.outDegrees=new Float64Array(r.order),this.starts=new c(r.order+1),this.nodes=r.nodes();var h,l,p,g,m,f,y,w,b,v={},A=0;for(h=0,l=r.order;h<l;h++)v[this.nodes[h]]=h;for(h=0,l=r.order;h<l;h++)for(y=s(m=this.nodes[h]),this.starts[h]=A,p=0,g=y.length;p<g;p++)w=y[p],f=r.opposite(m,w),b=d(w,r.getEdgeAttributes(w)),this.neighborhood[A]=v[f],this.weights[A++]=b,this.outDegrees[h]+=b;this.starts[h]=a}return r.prototype.bounds=function(e){return[this.starts[e],this.starts[e+1]]},r.prototype.project=function(){var e=this,t={};return e.nodes.forEach(function(n,r){t[n]=Array.from(e.neighborhood.slice(e.starts[r],e.starts[r+1])).map(function(t){return e.nodes[t]})}),t},r.prototype.collect=function(e){var t,n,r={};for(t=0,n=e.length;t<n;t++)r[this.nodes[t]]=e[t];return r},r.prototype.assign=function(e,t){var n=0;this.graph.updateEachNodeAttributes(function(r,i){return i[e]=t[n++],i},{attributes:[e]})},bt.NeighborhoodIndex=r,i.prototype.bounds=r.prototype.bounds,i.prototype.project=r.prototype.project,i.prototype.collect=r.prototype.collect,i.prototype.assign=r.prototype.assign,bt.WeightedNeighborhoodIndex=i,bt}const _t=f(function(){if(St)return Et;St=1;var e=ft(),t=yt(),n=Mt().WeightedNeighborhoodIndex,r={nodePagerankAttribute:"pagerank",getEdgeWeight:"weight",alpha:.85,maxIterations:100,tolerance:1e-6};function i(i,o,s){if(!e(o))throw new Error("graphology-metrics/centrality/pagerank: the given graph is not a valid graphology instance.");var a,c,u,d,h=(s=t(s,r)).alpha,l=s.maxIterations,p=s.tolerance,g=s.nodePagerankAttribute,m=o.order,f=1/m,y=new n(o,s.getEdgeWeight),w=new Float64Array(o.order),b=new Float64Array(y.weights.length),v=[];for(a=0;a<m;a++)for(w[a]=f,u=y.starts[a+1],0===(d=y.outDegrees[a])&&v.push(a),c=y.starts[a];c<u;c++)b[c]=y.weights[c]/d;for(var A,I,k=0,E=0,S=!1;k<l;){for(I=w,w=new Float64Array(o.order),A=0,a=0,u=v.length;a<u;a++)A+=I[v[a]];for(A*=h,a=0;a<m;a++){for(u=y.starts[a+1],c=y.starts[a];c<u;c++)w[y.neighborhood[c]]+=h*I[a]*b[c];w[a]+=A*f+(1-h)*f}for(E=0,a=0;a<m;a++)E+=Math.abs(w[a]-I[a]);if(E<m*p){S=!0;break}k++}if(!S)throw Error("graphology-metrics/centrality/pagerank: failed to converge.");if(!i)return y.collect(w);y.assign(g,w)}var o=i.bind(null,!1);return o.assign=i.bind(null,!0),Et=o}());var $t,Dt={};var Gt,Lt,Nt,Tt,jt,Ot,zt,Pt=function(){if($t)return Dt;$t=1;var e=ft();function t(t,n,r,i){var o=n+"Centrality";if(!e(r))throw new Error("graphology-centrality/"+o+": the given graph is not a valid graphology instance.");if("degree"!==n&&"undirected"===r.type)throw new Error("graphology-centrality/"+o+": cannot compute "+n+" centrality on an undirected graph.");var s=(i=i||{}).nodeCentralityAttribute||o,a=r.order-1,c=r[n].bind(r);if(!t){var u={};return r.forEachNode(function(e){u[e]=c(e)/a}),u}r.updateEachNodeAttributes(function(e,t){return t[s]=c(e)/a,t},{attributes:[s]})}var n=t.bind(null,!1,"degree"),r=t.bind(null,!1,"inDegree"),i=t.bind(null,!1,"outDegree");return n.assign=t.bind(null,!0,"degree"),r.assign=t.bind(null,!0,"inDegree"),i.assign=t.bind(null,!0,"outDegree"),Dt.degreeCentrality=n,Dt.inDegreeCentrality=r,Dt.outDegreeCentrality=i,Dt}(),Ut={},Wt={};function qt(){if(Lt)return Gt;Lt=1;var e=ie(),t=e.ARRAY_BUFFER_SUPPORT,n=e.SYMBOL_SUPPORT;return Gt=function(e,r){var i,o,s,a,c;if(!e)throw new Error("obliterator/forEach: invalid iterable.");if("function"!=typeof r)throw new Error("obliterator/forEach: expecting a callback.");if(Array.isArray(e)||t&&ArrayBuffer.isView(e)||"string"==typeof e||"[object Arguments]"===e.toString())for(s=0,a=e.length;s<a;s++)r(e[s],s);else if("function"!=typeof e.forEach)if(n&&Symbol.iterator in e&&"function"!=typeof e.next&&(e=e[Symbol.iterator]()),"function"!=typeof e.next)for(o in e)e.hasOwnProperty(o)&&r(e[o],o);else for(i=e,s=0;!0!==(c=i.next()).done;)r(c.value,s),s++;else e.forEach(r)}}function Rt(){if(Nt)return Wt;Nt=1;var e=qt(),t=At();function n(e){return"number"==typeof e.length?e.length:"number"==typeof e.size?e.size:void 0}return Wt.isArrayLike=function(e){return Array.isArray(e)||t.isTypedArray(e)},Wt.guessLength=n,Wt.toArray=function(t){var r=n(t),i="number"==typeof r?new Array(r):[],o=0;return e(t,function(e){i[o++]=e}),i},Wt.toArrayWithIndices=function(r){var i=n(r),o="number"==typeof i?t.getPointerArray(i):Array,s="number"==typeof i?new Array(i):[],a="number"==typeof i?new o(i):[],c=0;return e(r,function(e){s[c]=e,a[c]=c++}),[s,a]},Wt}var Ht,Ft,Bt,Qt,Vt,Jt,Kt={};function Yt(){if(Bt)return Ft;Bt=1;var e=qt(),t=(Ht||(Ht=1,Kt.DEFAULT_COMPARATOR=function(e,t){return e<t?-1:e>t?1:0},Kt.DEFAULT_REVERSE_COMPARATOR=function(e,t){return e<t?1:e>t?-1:0},Kt.reverseComparator=function(e){return function(t,n){return e(n,t)}},Kt.createTupleComparator=function(e){return 2===e?function(e,t){return e[0]<t[0]?-1:e[0]>t[0]?1:e[1]<t[1]?-1:e[1]>t[1]?1:0}:function(t,n){for(var r=0;r<e;){if(t[r]<n[r])return-1;if(t[r]>n[r])return 1;r++}return 0}}),Kt),n=Rt(),r=t.DEFAULT_COMPARATOR,i=t.reverseComparator;function o(e,t,n,r){for(var i,o,s=t[r];r>n&&e(s,o=t[i=r-1>>1])<0;)t[r]=o,r=i;t[r]=s}function s(e,t,n){for(var r,i=t.length,s=n,a=t[n],c=2*n+1;c<i;)(r=c+1)<i&&e(t[c],t[r])>=0&&(c=r),t[n]=t[c],c=2*(n=c)+1;t[n]=a,o(e,t,s,n)}function a(e,t,n){t.push(n),o(e,t,0,t.length-1)}function c(e,t){var n=t.pop();if(0!==t.length){var r=t[0];return t[0]=n,s(e,t,0),r}return n}function u(e,t,n){if(0===t.length)throw new Error("mnemonist/heap.replace: cannot pop an empty heap.");var r=t[0];return t[0]=n,s(e,t,0),r}function d(e,t,n){var r;return 0!==t.length&&e(t[0],n)<0&&(r=t[0],t[0]=n,n=r,s(e,t,0)),n}function h(e,t){for(var n=t.length>>1;--n>=0;)s(e,t,n)}function l(e,t){for(var n=t.length,r=0,i=new Array(n);r<n;)i[r++]=c(e,t);return i}function p(e){if(this.clear(),this.comparator=e||r,"function"!=typeof this.comparator)throw new Error("mnemonist/Heap.constructor: given comparator should be a function.")}function g(e){if(this.clear(),this.comparator=e||r,"function"!=typeof this.comparator)throw new Error("mnemonist/MaxHeap.constructor: given comparator should be a function.");this.comparator=i(this.comparator)}return p.prototype.clear=function(){this.items=[],this.size=0},p.prototype.push=function(e){return a(this.comparator,this.items,e),++this.size},p.prototype.peek=function(){return this.items[0]},p.prototype.pop=function(){return 0!==this.size&&this.size--,c(this.comparator,this.items)},p.prototype.replace=function(e){return u(this.comparator,this.items,e)},p.prototype.pushpop=function(e){return d(this.comparator,this.items,e)},p.prototype.consume=function(){return this.size=0,l(this.comparator,this.items)},p.prototype.toArray=function(){return l(this.comparator,this.items.slice())},p.prototype.inspect=function(){var e=this.toArray();return Object.defineProperty(e,"constructor",{value:p,enumerable:!1}),e},"undefined"!=typeof Symbol&&(p.prototype[Symbol.for("nodejs.util.inspect.custom")]=p.prototype.inspect),g.prototype=p.prototype,p.from=function(e,t){var r,i=new p(t);return r=n.isArrayLike(e)?e.slice():n.toArray(e),h(i.comparator,r),i.items=r,i.size=r.length,i},g.from=function(e,t){var r,i=new g(t);return r=n.isArrayLike(e)?e.slice():n.toArray(e),h(i.comparator,r),i.items=r,i.size=r.length,i},p.siftUp=s,p.siftDown=o,p.push=a,p.pop=c,p.replace=u,p.pushpop=d,p.heapify=h,p.consume=l,p.nsmallest=function(t,o,s){2===arguments.length&&(s=o,o=t,t=r);var a,c,d,l,p=i(t),g=1/0;if(1===o){if(n.isArrayLike(s)){for(a=0,c=s.length;a<c;a++)d=s[a],(g===1/0||t(d,g)<0)&&(g=d);return(l=new s.constructor(1))[0]=g,l}return e(s,function(e){(g===1/0||t(e,g)<0)&&(g=e)}),[g]}if(n.isArrayLike(s)){if(o>=s.length)return s.slice().sort(t);for(l=s.slice(0,o),h(p,l),a=o,c=s.length;a<c;a++)p(s[a],l[0])>0&&u(p,l,s[a]);return l.sort(t)}var m=n.guessLength(s);return null!==m&&m<o&&(o=m),l=new Array(o),a=0,e(s,function(e){a<o?l[a]=e:(a===o&&h(p,l),p(e,l[0])>0&&u(p,l,e)),a++}),l.length>a&&(l.length=a),l.sort(t)},p.nlargest=function(t,o,s){2===arguments.length&&(s=o,o=t,t=r);var a,c,d,l,p=i(t),g=-1/0;if(1===o){if(n.isArrayLike(s)){for(a=0,c=s.length;a<c;a++)d=s[a],(g===-1/0||t(d,g)>0)&&(g=d);return(l=new s.constructor(1))[0]=g,l}return e(s,function(e){(g===-1/0||t(e,g)>0)&&(g=e)}),[g]}if(n.isArrayLike(s)){if(o>=s.length)return s.slice().sort(p);for(l=s.slice(0,o),h(t,l),a=o,c=s.length;a<c;a++)t(s[a],l[0])>0&&u(t,l,s[a]);return l.sort(p)}var m=n.guessLength(s);return null!==m&&m<o&&(o=m),l=new Array(o),a=0,e(s,function(e){a<o?l[a]=e:(a===o&&h(t,l),t(e,l[0])>0&&u(t,l,e)),a++}),l.length>a&&(l.length=a),l.sort(p)},p.MinHeap=p,p.MaxHeap=g,Ft=p}function Zt(){if(Qt)return Ut;Qt=1;var e=function(){if(jt)return Tt;jt=1;var e=Rt(),t=K();function n(e,t){if(arguments.length<2)throw new Error("mnemonist/fixed-deque: expecting an Array class and a capacity.");if("number"!=typeof t||t<=0)throw new Error("mnemonist/fixed-deque: `capacity` should be a positive number.");this.ArrayClass=e,this.capacity=t,this.items=new e(this.capacity),this.clear()}return n.prototype.clear=function(){this.start=0,this.size=0},n.prototype.push=function(e){if(this.size===this.capacity)throw new Error("mnemonist/fixed-deque.push: deque capacity ("+this.capacity+") exceeded!");var t=this.start+this.size;return t>=this.capacity&&(t-=this.capacity),this.items[t]=e,++this.size},n.prototype.unshift=function(e){if(this.size===this.capacity)throw new Error("mnemonist/fixed-deque.unshift: deque capacity ("+this.capacity+") exceeded!");var t=this.start-1;return 0===this.start&&(t=this.capacity-1),this.items[t]=e,this.start=t,++this.size},n.prototype.pop=function(){if(0!==this.size){this.size--;var e=this.start+this.size;return e>=this.capacity&&(e-=this.capacity),this.items[e]}},n.prototype.shift=function(){if(0!==this.size){var e=this.start;return this.size--,this.start++,this.start===this.capacity&&(this.start=0),this.items[e]}},n.prototype.peekFirst=function(){if(0!==this.size)return this.items[this.start]},n.prototype.peekLast=function(){if(0!==this.size){var e=this.start+this.size-1;return e>=this.capacity&&(e-=this.capacity),this.items[e]}},n.prototype.get=function(e){if(!(0===this.size||e>=this.capacity))return(e=this.start+e)>=this.capacity&&(e-=this.capacity),this.items[e]},n.prototype.forEach=function(e,t){t=arguments.length>1?t:this;for(var n=this.capacity,r=this.size,i=this.start,o=0;o<r;)e.call(t,this.items[i],o,this),o++,++i===n&&(i=0)},n.prototype.toArray=function(){var e=this.start+this.size;if(e<this.capacity)return this.items.slice(this.start,e);for(var t=new this.ArrayClass(this.size),n=this.capacity,r=this.size,i=this.start,o=0;o<r;)t[o]=this.items[i],o++,++i===n&&(i=0);return t},n.prototype.values=function(){var e=this.items,n=this.capacity,r=this.size,i=this.start,o=0;return new t(function(){if(o>=r)return{done:!0};var t=e[i];return i++,o++,i===n&&(i=0),{value:t,done:!1}})},n.prototype.entries=function(){var e=this.items,n=this.capacity,r=this.size,i=this.start,o=0;return new t(function(){if(o>=r)return{done:!0};var t=e[i];return++i===n&&(i=0),{value:[o++,t],done:!1}})},"undefined"!=typeof Symbol&&(n.prototype[Symbol.iterator]=n.prototype.values),n.prototype.inspect=function(){var e=this.toArray();return e.type=this.ArrayClass.name,e.capacity=this.capacity,Object.defineProperty(e,"constructor",{value:n,enumerable:!1}),e},"undefined"!=typeof Symbol&&(n.prototype[Symbol.for("nodejs.util.inspect.custom")]=n.prototype.inspect),n.from=function(t,r,i){if(arguments.length<3&&"number"!=typeof(i=e.guessLength(t)))throw new Error("mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.");var o=new n(r,i);if(e.isArrayLike(t)){var s,a;for(s=0,a=t.length;s<a;s++)o.items[s]=t[s];return o.size=a,o}return e.forEach(t,function(e){o.push(e)}),o},Tt=n}(),t=function(){if(zt)return Ot;zt=1;var e=K(),t=Rt();function n(e,t){if(arguments.length<2)throw new Error("mnemonist/fixed-stack: expecting an Array class and a capacity.");if("number"!=typeof t||t<=0)throw new Error("mnemonist/fixed-stack: `capacity` should be a positive number.");this.capacity=t,this.ArrayClass=e,this.items=new this.ArrayClass(this.capacity),this.clear()}return n.prototype.clear=function(){this.size=0},n.prototype.push=function(e){if(this.size===this.capacity)throw new Error("mnemonist/fixed-stack.push: stack capacity ("+this.capacity+") exceeded!");return this.items[this.size++]=e,this.size},n.prototype.pop=function(){if(0!==this.size)return this.items[--this.size]},n.prototype.peek=function(){return this.items[this.size-1]},n.prototype.forEach=function(e,t){t=arguments.length>1?t:this;for(var n=0,r=this.items.length;n<r;n++)e.call(t,this.items[r-n-1],n,this)},n.prototype.toArray=function(){for(var e=new this.ArrayClass(this.size),t=this.size-1,n=this.size;n--;)e[n]=this.items[t-n];return e},n.prototype.values=function(){var t=this.items,n=this.size,r=0;return new e(function(){if(r>=n)return{done:!0};var e=t[n-r-1];return r++,{value:e,done:!1}})},n.prototype.entries=function(){var t=this.items,n=this.size,r=0;return new e(function(){if(r>=n)return{done:!0};var e=t[n-r-1];return{value:[r++,e],done:!1}})},"undefined"!=typeof Symbol&&(n.prototype[Symbol.iterator]=n.prototype.values),n.prototype.toString=function(){return this.toArray().join(",")},n.prototype.toJSON=function(){return this.toArray()},n.prototype.inspect=function(){var e=this.toArray();return e.type=this.ArrayClass.name,e.capacity=this.capacity,Object.defineProperty(e,"constructor",{value:n,enumerable:!1}),e},"undefined"!=typeof Symbol&&(n.prototype[Symbol.for("nodejs.util.inspect.custom")]=n.prototype.inspect),n.from=function(e,r,i){if(arguments.length<3&&"number"!=typeof(i=t.guessLength(e)))throw new Error("mnemonist/fixed-stack.from: could not guess iterable length. Please provide desired capacity as last argument.");var o=new n(r,i);if(t.isArrayLike(e)){var s,a;for(s=0,a=e.length;s<a;s++)o.items[s]=e[s];return o.size=a,o}return t.forEach(e,function(e){o.push(e)}),o},Ot=n}(),n=Yt(),r=At(),i=Mt(),o=i.NeighborhoodIndex,s=i.WeightedNeighborhoodIndex;function a(e,t){return e[0]>t[0]?1:e[0]<t[0]?-1:e[1]>t[1]?1:e[1]<t[1]?-1:e[2]>t[2]?1:e[2]<t[2]?-1:e[3]>t[3]?1:e[3]<t[3]?-1:0}return Ut.createUnweightedIndexedBrandes=function(n){var i=new o(n),s=i.neighborhood,a=i.starts,c=n.order,u=new t(r.getPointerArray(c),c),d=new Uint32Array(c),h=new Array(c),l=new Int32Array(c),p=new e(Uint32Array,c),g=function(e){var t,n,r,i,o,g,m;for(g=0;g<c;g++)h[g]=[],d[g]=0,l[g]=-1;for(d[e]=1,l[e]=0,p.push(e);0!==p.size;)for(g=p.shift(),u.push(g),t=l[g],n=d[g],r=a[g],i=a[g+1],o=r;o<i;o++)m=s[o],-1===l[m]&&(p.push(m),l[m]=t+1),l[m]===t+1&&(d[m]+=n,h[m].push(g));return[u,h,d]};return g.index=i,g},Ut.createDijkstraIndexedBrandes=function(e,i){var o=new s(e,i||"weight"),c=o.neighborhood,u=o.weights,d=o.starts,h=e.order,l=new t(r.getPointerArray(h),h),p=new Uint32Array(h),g=new Array(h),m=new Float64Array(h),f=new Float64Array(h),y=new n(a),w=function(e){var t,n,r,i,o,s,a,w,b,v=0;for(w=0;w<h;w++)g[w]=[],p[w]=0,m[w]=-1,f[w]=-1;for(p[e]=1,f[e]=0,y.push([0,v++,e,e]);0!==y.size;)if(i=(r=y.pop())[0],o=r[2],w=r[3],-1===m[w])for(l.push(w),m[w]=i,p[w]+=p[o],t=d[w],n=d[w+1],a=t;a<n;a++)b=c[a],s=i+u[a],-1===m[b]&&(-1===f[b]||s<f[b])?(f[b]=s,y.push([s,v++,w,b]),p[b]=0,g[b]=[w]):s===f[b]&&(p[b]+=p[w],g[b].push(w));return[l,g,p]};return w.index=o,w},Ut}const Xt=f(function(){if(Jt)return Vt;Jt=1;var e=ft(),t=Zt(),n=yt(),r=t.createUnweightedIndexedBrandes,i=t.createDijkstraIndexedBrandes,o={nodeCentralityAttribute:"betweennessCentrality",getEdgeWeight:"weight",normalized:!0};function s(t,s,a){if(!e(s))throw new Error("graphology-centrality/beetweenness-centrality: the given graph is not a valid graphology instance.");var c,u,d,h,l,p,g,m,f,y,w=(a=n(a,o)).nodeCentralityAttribute,b=a.normalized,v=a.getEdgeWeight?i(s,a.getEdgeWeight):r(s),A=s.order,I=new Float64Array(A),k=new Float64Array(A);for(p=0;p<A;p++){for(u=(c=v(p))[0],d=c[1],h=c[2],g=u.size;g--;)I[u.items[u.size-g]]=0;for(;0!==u.size;){for(l=(1+I[y=u.pop()])/h[y],g=0,m=d[y].length;g<m;g++)I[f=d[y][g]]+=h[f]*l;y!==p&&(k[y]+=I[y])}}var E=null;if(null!==(E=b?A<=2?null:1/((A-1)*(A-2)):"undirected"===s.type?.5:null))for(p=0;p<A;p++)k[p]*=E;return t?v.index.assign(w,k):v.index.collect(k)}var a=s.bind(null,!1);return a.assign=s.bind(null,!0),Vt=a}());var en,tn,nn,rn,on,sn,an,cn;var un,dn,hn,ln={};const pn=f(function(){if(hn)return dn;hn=1;var e=yt(),t=ft(),n=function(){if(tn)return en;tn=1;var e=ft();return en=function(t){if(!e(t))throw new Error("graphology-utils/infer-type: expecting a valid graphology instance.");var n=t.type;return"mixed"!==n?n:0===t.directedSize&&0===t.undirectedSize||t.directedSize>0&&t.undirectedSize>0?"mixed":t.directedSize>0?"directed":"undirected"}}(),r=function(){if(rn)return nn;rn=1;var e=K(),t=At().getPointerArray;function n(e,n){arguments.length<2&&(n=e,e=Array);var r=t(n);this.size=0,this.length=n,this.dense=new r(n),this.sparse=new r(n),this.vals=new e(n)}return n.prototype.clear=function(){this.size=0},n.prototype.has=function(e){var t=this.sparse[e];return t<this.size&&this.dense[t]===e},n.prototype.get=function(e){var t=this.sparse[e];if(t<this.size&&this.dense[t]===e)return this.vals[t]},n.prototype.set=function(e,t){var n=this.sparse[e];return n<this.size&&this.dense[n]===e?(this.vals[n]=t,this):(this.dense[this.size]=e,this.sparse[e]=this.size,this.vals[this.size]=t,this.size++,this)},n.prototype.delete=function(e){var t=this.sparse[e];return!(t>=this.size||this.dense[t]!==e||(t=this.dense[this.size-1],this.dense[this.sparse[e]]=t,this.sparse[t]=this.sparse[e],this.size--,0))},n.prototype.forEach=function(e,t){t=arguments.length>1?t:this;for(var n=0;n<this.size;n++)e.call(t,this.vals[n],this.dense[n])},n.prototype.keys=function(){var t=this.size,n=this.dense,r=0;return new e(function(){if(r<t){var e=n[r];return r++,{value:e}}return{done:!0}})},n.prototype.values=function(){var t=this.size,n=this.vals,r=0;return new e(function(){if(r<t){var e=n[r];return r++,{value:e}}return{done:!0}})},n.prototype.entries=function(){var t=this.size,n=this.dense,r=this.vals,i=0;return new e(function(){if(i<t){var e=[n[i],r[i]];return i++,{value:e}}return{done:!0}})},"undefined"!=typeof Symbol&&(n.prototype[Symbol.iterator]=n.prototype.entries),n.prototype.inspect=function(){for(var e=new Map,t=0;t<this.size;t++)e.set(this.dense[t],this.vals[t]);return Object.defineProperty(e,"constructor",{value:n,enumerable:!1}),e.length=this.length,this.vals.constructor!==Array&&(e.type=this.vals.constructor.name),e},"undefined"!=typeof Symbol&&(n.prototype[Symbol.for("nodejs.util.inspect.custom")]=n.prototype.inspect),nn=n}(),i=function(){if(sn)return on;sn=1;var e=K(),t=At().getPointerArray;function n(e){var n=t(e);this.start=0,this.size=0,this.capacity=e,this.dense=new n(e),this.sparse=new n(e)}return n.prototype.clear=function(){this.start=0,this.size=0},n.prototype.has=function(e){if(0===this.size)return!1;var t=this.sparse[e];return(t<this.capacity&&t>=this.start&&t<this.start+this.size||t<(this.start+this.size)%this.capacity)&&this.dense[t]===e},n.prototype.enqueue=function(e){var t=this.sparse[e];return 0!==this.size&&(t<this.capacity&&t>=this.start&&t<this.start+this.size||t<(this.start+this.size)%this.capacity)&&this.dense[t]===e||(t=(this.start+this.size)%this.capacity,this.dense[t]=e,this.sparse[e]=t,this.size++),this},n.prototype.dequeue=function(){if(0!==this.size){var e=this.start;this.size--,this.start++,this.start===this.capacity&&(this.start=0);var t=this.dense[e];return this.sparse[t]=this.capacity,t}},n.prototype.forEach=function(e,t){t=arguments.length>1?t:this;for(var n=this.capacity,r=this.size,i=this.start,o=0;o<r;)e.call(t,this.dense[i],o,this),o++,++i===n&&(i=0)},n.prototype.values=function(){var t=this.dense,n=this.capacity,r=this.size,i=this.start,o=0;return new e(function(){if(o>=r)return{done:!0};var e=t[i];return i++,o++,i===n&&(i=0),{value:e,done:!1}})},"undefined"!=typeof Symbol&&(n.prototype[Symbol.iterator]=n.prototype.values),n.prototype.inspect=function(){var e=[];return this.forEach(function(t){e.push(t)}),Object.defineProperty(e,"constructor",{value:n,enumerable:!1}),e.capacity=this.capacity,e},"undefined"!=typeof Symbol&&(n.prototype[Symbol.for("nodejs.util.inspect.custom")]=n.prototype.inspect),on=n}(),o=function(){if(cn)return an;function e(e){return function(t){return"number"!=typeof t&&(t=t.length),Math.floor(e()*t)}}cn=1;var t=e(Math.random);return t.createRandomIndex=e,an=t}().createRandomIndex,s=function(){if(un)return ln;un=1;var e=At(),t=yt(),n=Ct().createEdgeWeightGetter,r=Symbol.for("nodejs.util.inspect.custom"),i={getEdgeWeight:"weight",keepDendrogram:!1,resolution:1};function o(r,o){var s=(o=t(o,i)).resolution,a=n(o.getEdgeWeight).fromEntry,c=2*(r.size-r.selfLoopCount),u=e.getPointerArray(c),d=e.getPointerArray(r.order+1),h=o.getEdgeWeight?Float64Array:e.getPointerArray(2*r.size);this.C=r.order,this.M=0,this.E=c,this.U=0,this.resolution=s,this.level=0,this.graph=r,this.nodes=new Array(r.order),this.keepDendrogram=o.keepDendrogram,this.neighborhood=new d(c),this.weights=new h(c),this.loops=new h(r.order),this.starts=new u(r.order+1),this.belongings=new d(r.order),this.dendrogram=[],this.mapping=null,this.counts=new d(r.order),this.unused=new d(r.order),this.totalWeights=new h(r.order);var l,p={},g=0,m=0,f=this;r.forEachNode(function(e){f.nodes[g]=e,p[e]=g,m+=r.undirectedDegreeWithoutSelfLoops(e),f.starts[g]=m,f.belongings[g]=g,f.counts[g]=1,g++}),r.forEachEdge(function(e,t,n,r,i,o,s){if(l=a(e,t,n,r,i,o,s),n=p[n],r=p[r],f.M+=l,n===r)f.totalWeights[n]+=2*l,f.loops[n]=2*l;else{f.totalWeights[n]+=l,f.totalWeights[r]+=l;var c=--f.starts[n],u=--f.starts[r];f.neighborhood[c]=r,f.neighborhood[u]=n,f.weights[c]=l,f.weights[u]=l}}),this.starts[g]=this.E,this.keepDendrogram?this.dendrogram.push(this.belongings.slice()):this.mapping=this.belongings.slice()}function s(r,o){var s=(o=t(o,i)).resolution,a=n(o.getEdgeWeight).fromEntry,c=2*(r.size-r.selfLoopCount),u=e.getPointerArray(c),d=e.getPointerArray(r.order+1),h=o.getEdgeWeight?Float64Array:e.getPointerArray(2*r.size);this.C=r.order,this.M=0,this.E=c,this.U=0,this.resolution=s,this.level=0,this.graph=r,this.nodes=new Array(r.order),this.keepDendrogram=o.keepDendrogram,this.neighborhood=new d(c),this.weights=new h(c),this.loops=new h(r.order),this.starts=new u(r.order+1),this.offsets=new u(r.order),this.belongings=new d(r.order),this.dendrogram=[],this.counts=new d(r.order),this.unused=new d(r.order),this.totalInWeights=new h(r.order),this.totalOutWeights=new h(r.order);var l,p={},g=0,m=0,f=this;r.forEachNode(function(e){f.nodes[g]=e,p[e]=g,m+=r.outDegreeWithoutSelfLoops(e),f.starts[g]=m,m+=r.inDegreeWithoutSelfLoops(e),f.offsets[g]=m,f.belongings[g]=g,f.counts[g]=1,g++}),r.forEachEdge(function(e,t,n,r,i,o,s){if(l=a(e,t,n,r,i,o,s),n=p[n],r=p[r],f.M+=l,n===r)f.loops[n]+=l,f.totalInWeights[n]+=l,f.totalOutWeights[n]+=l;else{f.totalOutWeights[n]+=l,f.totalInWeights[r]+=l;var c=--f.starts[n],u=--f.offsets[r];f.neighborhood[c]=r,f.neighborhood[u]=n,f.weights[c]=l,f.weights[u]=l}}),this.starts[g]=this.E,this.keepDendrogram?this.dendrogram.push(this.belongings.slice()):this.mapping=this.belongings.slice()}return o.prototype.isolate=function(e,t){var n=this.belongings[e];if(1===this.counts[n])return n;var r=this.unused[--this.U],i=this.loops[e];return this.totalWeights[n]-=t+i,this.totalWeights[r]+=t+i,this.belongings[e]=r,this.counts[n]--,this.counts[r]++,r},o.prototype.move=function(e,t,n){var r=this.belongings[e],i=this.loops[e];this.totalWeights[r]-=t+i,this.totalWeights[n]+=t+i,this.belongings[e]=n;var o=1===this.counts[r]--;this.counts[n]++,o&&(this.unused[this.U++]=r)},o.prototype.computeNodeDegree=function(e){var t,n,r=0;for(t=this.starts[e],n=this.starts[e+1];t<n;t++)r+=this.weights[t];return r},o.prototype.expensiveIsolate=function(e){var t=this.computeNodeDegree(e);return this.isolate(e,t)},o.prototype.expensiveMove=function(e,t){var n=this.computeNodeDegree(e);this.move(e,n,t)},o.prototype.zoomOut=function(){var t,n,r,i,o,s,a,c,u,d,h,l=new Array(this.C-this.U),p={},g=this.nodes.length,m=0,f=0;for(t=0,r=this.C;t<r;t++)(s=this.belongings[t])in p||(p[s]=m,l[m]={adj:{},totalWeights:this.totalWeights[s],internalWeights:0},m++),this.belongings[t]=p[s];if(this.keepDendrogram){for(d=this.dendrogram[this.level],h=new(e.getPointerArray(m))(g),t=0;t<g;t++)h[t]=this.belongings[d[t]];this.dendrogram.push(h)}else for(t=0;t<g;t++)this.mapping[t]=this.belongings[this.mapping[t]];for(t=0,r=this.C;t<r;t++)for(u=(c=l[s=this.belongings[t]]).adj,c.internalWeights+=this.loops[t],n=this.starts[t],i=this.starts[t+1];n<i;n++)o=this.neighborhood[n],s!==(a=this.belongings[o])?(a in u||(u[a]=0),u[a]+=this.weights[n]):c.internalWeights+=this.weights[n];for(this.C=m,o=0,s=0;s<m;s++)for(a in u=(c=l[s]).adj,s=+s,this.totalWeights[s]=c.totalWeights,this.loops[s]=c.internalWeights,this.counts[s]=1,this.starts[s]=o,this.belongings[s]=s,u)this.neighborhood[o]=+a,this.weights[o]=u[a],f++,o++;return this.starts[m]=f,this.E=f,this.U=0,this.level++,p},o.prototype.modularity=function(){var e,t,n,r,i=0,o=2*this.M,s=new Float64Array(this.C);for(t=0;t<this.C;t++)for(s[e=this.belongings[t]]+=this.loops[t],n=this.starts[t],r=this.starts[t+1];n<r;n++)e===this.belongings[this.neighborhood[n]]&&(s[e]+=this.weights[n]);for(t=0;t<this.C;t++)i+=s[t]/o-Math.pow(this.totalWeights[t]/o,2)*this.resolution;return i},o.prototype.delta=function(e,t,n,r){var i=this.M;return n/i-this.totalWeights[r]*(t+=this.loops[e])*this.resolution/(2*i*i)},o.prototype.deltaWithOwnCommunity=function(e,t,n,r){var i=this.M;return n/i-(this.totalWeights[r]-(t+=this.loops[e]))*t*this.resolution/(2*i*i)},o.prototype.fastDelta=function(e,t,n,r){var i=this.M,o=this.totalWeights[r];return n-(t+=this.loops[e])*o*this.resolution/(2*i)},o.prototype.fastDeltaWithOwnCommunity=function(e,t,n,r){var i=this.M,o=this.totalWeights[r];return n-(t+=this.loops[e])*(o-t)*this.resolution/(2*i)},o.prototype.bounds=function(e){return[this.starts[e],this.starts[e+1]]},o.prototype.project=function(){var e=this,t={};return e.nodes.slice(0,this.C).forEach(function(n,r){t[n]=Array.from(e.neighborhood.slice(e.starts[r],e.starts[r+1])).map(function(t){return e.nodes[t]})}),t},o.prototype.collect=function(e){arguments.length<1&&(e=this.level);var t,n,r={},i=this.keepDendrogram?this.dendrogram[e]:this.mapping;for(t=0,n=i.length;t<n;t++)r[this.nodes[t]]=i[t];return r},o.prototype.assign=function(e,t){arguments.length<2&&(t=this.level);var n,r,i=this.keepDendrogram?this.dendrogram[t]:this.mapping;for(n=0,r=i.length;n<r;n++)this.graph.setNodeAttribute(this.nodes[n],e,i[n])},o.prototype[r]=function(){var e={};Object.defineProperty(e,"constructor",{value:o,enumerable:!1}),e.C=this.C,e.M=this.M,e.E=this.E,e.U=this.U,e.resolution=this.resolution,e.level=this.level,e.nodes=this.nodes,e.starts=this.starts.slice(0,e.C+1);var t=this;return["neighborhood","weights"].forEach(function(n){e[n]=t[n].slice(0,e.E)}),["counts","loops","belongings","totalWeights"].forEach(function(n){e[n]=t[n].slice(0,e.C)}),e.unused=this.unused.slice(0,this.U),this.keepDendrogram?e.dendrogram=this.dendrogram:e.mapping=this.mapping,e},s.prototype.bounds=o.prototype.bounds,s.prototype.inBounds=function(e){return[this.offsets[e],this.starts[e+1]]},s.prototype.outBounds=function(e){return[this.starts[e],this.offsets[e]]},s.prototype.project=o.prototype.project,s.prototype.projectIn=function(){var e=this,t={};return e.nodes.slice(0,this.C).forEach(function(n,r){t[n]=Array.from(e.neighborhood.slice(e.offsets[r],e.starts[r+1])).map(function(t){return e.nodes[t]})}),t},s.prototype.projectOut=function(){var e=this,t={};return e.nodes.slice(0,this.C).forEach(function(n,r){t[n]=Array.from(e.neighborhood.slice(e.starts[r],e.offsets[r])).map(function(t){return e.nodes[t]})}),t},s.prototype.isolate=function(e,t,n){var r=this.belongings[e];if(1===this.counts[r])return r;var i=this.unused[--this.U],o=this.loops[e];return this.totalInWeights[r]-=t+o,this.totalInWeights[i]+=t+o,this.totalOutWeights[r]-=n+o,this.totalOutWeights[i]+=n+o,this.belongings[e]=i,this.counts[r]--,this.counts[i]++,i},s.prototype.move=function(e,t,n,r){var i=this.belongings[e],o=this.loops[e];this.totalInWeights[i]-=t+o,this.totalInWeights[r]+=t+o,this.totalOutWeights[i]-=n+o,this.totalOutWeights[r]+=n+o,this.belongings[e]=r;var s=1===this.counts[i]--;this.counts[r]++,s&&(this.unused[this.U++]=i)},s.prototype.computeNodeInDegree=function(e){var t,n,r=0;for(t=this.offsets[e],n=this.starts[e+1];t<n;t++)r+=this.weights[t];return r},s.prototype.computeNodeOutDegree=function(e){var t,n,r=0;for(t=this.starts[e],n=this.offsets[e];t<n;t++)r+=this.weights[t];return r},s.prototype.expensiveMove=function(e,t){var n=this.computeNodeInDegree(e),r=this.computeNodeOutDegree(e);this.move(e,n,r,t)},s.prototype.zoomOut=function(){var t,n,r,i,o,s,a,c,u,d,h,l,p,g,m,f=new Array(this.C-this.U),y={},w=this.nodes.length,b=0,v=0;for(t=0,r=this.C;t<r;t++)(s=this.belongings[t])in y||(y[s]=b,f[b]={inAdj:{},outAdj:{},totalInWeights:this.totalInWeights[s],totalOutWeights:this.totalOutWeights[s],internalWeights:0},b++),this.belongings[t]=y[s];if(this.keepDendrogram){for(g=this.dendrogram[this.level],m=new(e.getPointerArray(b))(w),t=0;t<w;t++)m[t]=this.belongings[g[t]];this.dendrogram.push(m)}else for(t=0;t<w;t++)this.mapping[t]=this.belongings[this.mapping[t]];for(t=0,r=this.C;t<r;t++)for(s=this.belongings[t],u=this.offsets[t],l=(c=f[s]).inAdj,p=c.outAdj,c.internalWeights+=this.loops[t],n=this.starts[t],i=this.starts[t+1];n<i;n++)o=this.neighborhood[n],h=(d=n<u)?p:l,s!==(a=this.belongings[o])?(a in h||(h[a]=0),h[a]+=this.weights[n]):d&&(c.internalWeights+=this.weights[n]);for(this.C=b,o=0,s=0;s<b;s++){for(a in l=(c=f[s]).inAdj,p=c.outAdj,s=+s,this.totalInWeights[s]=c.totalInWeights,this.totalOutWeights[s]=c.totalOutWeights,this.loops[s]=c.internalWeights,this.counts[s]=1,this.starts[s]=o,this.belongings[s]=s,p)this.neighborhood[o]=+a,this.weights[o]=p[a],v++,o++;for(a in this.offsets[s]=o,l)this.neighborhood[o]=+a,this.weights[o]=l[a],v++,o++}return this.starts[b]=v,this.E=v,this.U=0,this.level++,y},s.prototype.modularity=function(){var e,t,n,r,i=0,o=this.M,s=new Float64Array(this.C);for(t=0;t<this.C;t++)for(s[e=this.belongings[t]]+=this.loops[t],n=this.starts[t],r=this.offsets[t];n<r;n++)e===this.belongings[this.neighborhood[n]]&&(s[e]+=this.weights[n]);for(t=0;t<this.C;t++)i+=s[t]/o-this.totalInWeights[t]*this.totalOutWeights[t]/Math.pow(o,2)*this.resolution;return i},s.prototype.delta=function(e,t,n,r,i){var o=this.M,s=this.totalInWeights[i],a=this.totalOutWeights[i],c=this.loops[e];return r/o-((n+=c)*s+(t+=c)*a)*this.resolution/(o*o)},s.prototype.deltaWithOwnCommunity=function(e,t,n,r,i){var o=this.M,s=this.totalInWeights[i],a=this.totalOutWeights[i],c=this.loops[e];return r/o-((n+=c)*(s-(t+=c))+t*(a-n))*this.resolution/(o*o)},s.prototype.collect=o.prototype.collect,s.prototype.assign=o.prototype.assign,s.prototype[r]=function(){var e={};Object.defineProperty(e,"constructor",{value:s,enumerable:!1}),e.C=this.C,e.M=this.M,e.E=this.E,e.U=this.U,e.resolution=this.resolution,e.level=this.level,e.nodes=this.nodes,e.starts=this.starts.slice(0,e.C+1);var t=this;return["neighborhood","weights"].forEach(function(n){e[n]=t[n].slice(0,e.E)}),["counts","offsets","loops","belongings","totalInWeights","totalOutWeights"].forEach(function(n){e[n]=t[n].slice(0,e.C)}),e.unused=this.unused.slice(0,this.U),this.keepDendrogram?e.dendrogram=this.dendrogram:e.mapping=this.mapping,e},ln.UndirectedLouvainIndex=o,ln.DirectedLouvainIndex=s,ln}(),a=s.UndirectedLouvainIndex,c=s.DirectedLouvainIndex,u={nodeCommunityAttribute:"community",getEdgeWeight:"weight",fastLocalMoves:!0,randomWalk:!0,resolution:1,rng:Math.random};function d(e,t,n){var r=e.get(t);void 0===r&&(r=0),r+=n,e.set(t,r)}function h(e,t,n,r,i){return Math.abs(r-i)<1e-10?e!==t&&n>e:r>i}function l(e,t,n){var s,c,u,l,p,g,m,f,y,w,b,v,A,I,k,E,S,x,C,M=new a(t,{getEdgeWeight:n.getEdgeWeight,keepDendrogram:e,resolution:n.resolution}),_=o(n.rng),$=!0,D=!0,G=new r(Float64Array,M.C),L=0,N=0,T=[];for(n.fastLocalMoves&&(u=new i(M.C));$;){if(v=M.C,$=!1,D=!0,n.fastLocalMoves){for(C=0,f=n.randomWalk?_(v):0,y=0;y<v;y++,f++)w=f%v,u.enqueue(w);for(;0!==u.size;){for(w=u.dequeue(),N++,A=0,G.clear(),s=M.belongings[w],l=M.starts[w],p=M.starts[w+1];l<p;l++)b=M.neighborhood[l],A+=g=M.weights[l],d(G,c=M.belongings[b],g);for(E=M.fastDeltaWithOwnCommunity(w,A,G.get(s)||0,s),k=s,m=0;m<G.size;m++)(c=G.dense[m])!==s&&(I=G.vals[m],L++,h(k,s,c,S=M.fastDelta(w,A,I,c),E)&&(E=S,k=c));if(E<0){if((k=M.isolate(w,A))===s)continue}else{if(k===s)continue;M.move(w,A,k)}for($=!0,C++,l=M.starts[w],p=M.starts[w+1];l<p;l++)b=M.neighborhood[l],(c=M.belongings[b])!==k&&u.enqueue(b)}T.push(C)}else for(x=[],T.push(x);D;){for(D=!1,C=0,f=n.randomWalk?_(v):0,y=0;y<v;y++,f++){for(w=f%v,N++,A=0,G.clear(),s=M.belongings[w],l=M.starts[w],p=M.starts[w+1];l<p;l++)b=M.neighborhood[l],A+=g=M.weights[l],d(G,c=M.belongings[b],g);for(E=M.fastDeltaWithOwnCommunity(w,A,G.get(s)||0,s),k=s,m=0;m<G.size;m++)(c=G.dense[m])!==s&&(I=G.vals[m],L++,h(k,s,c,S=M.fastDelta(w,A,I,c),E)&&(E=S,k=c));if(E<0){if((k=M.isolate(w,A))===s)continue}else{if(k===s)continue;M.move(w,A,k)}D=!0,C++}x.push(C),$=D||$}$&&M.zoomOut()}return{index:M,deltaComputations:L,nodesVisited:N,moves:T}}function p(e,t,n){var s,a,u,l,p,g,m,f,y,w,b,v,A,I,k,E,S,x,C,M,_,$,D=new c(t,{getEdgeWeight:n.getEdgeWeight,keepDendrogram:e,resolution:n.resolution}),G=o(n.rng),L=!0,N=!0,T=new r(Float64Array,D.C),j=0,O=0,z=[];for(n.fastLocalMoves&&(u=new i(D.C));L;){if(I=D.C,L=!1,N=!0,n.fastLocalMoves){for($=0,w=n.randomWalk?G(I):0,b=0;b<I;b++,w++)v=w%I,u.enqueue(v);for(;0!==u.size;){for(v=u.dequeue(),O++,k=0,E=0,T.clear(),s=D.belongings[v],l=D.starts[v],p=D.starts[v+1],g=D.offsets[v];l<p;l++)m=l<g,A=D.neighborhood[l],f=D.weights[l],m?E+=f:k+=f,d(T,a=D.belongings[A],f);for(C=D.deltaWithOwnCommunity(v,k,E,T.get(s)||0,s),x=s,y=0;y<T.size;y++)(a=T.dense[y])!==s&&(S=T.vals[y],j++,h(x,s,a,M=D.delta(v,k,E,S,a),C)&&(C=M,x=a));if(C<0){if((x=D.isolate(v,k,E))===s)continue}else{if(x===s)continue;D.move(v,k,E,x)}for(L=!0,$++,l=D.starts[v],p=D.starts[v+1];l<p;l++)A=D.neighborhood[l],(a=D.belongings[A])!==x&&u.enqueue(A)}z.push($)}else for(_=[],z.push(_);N;){for(N=!1,$=0,w=n.randomWalk?G(I):0,b=0;b<I;b++,w++){for(v=w%I,O++,k=0,E=0,T.clear(),s=D.belongings[v],l=D.starts[v],p=D.starts[v+1],g=D.offsets[v];l<p;l++)m=l<g,A=D.neighborhood[l],f=D.weights[l],m?E+=f:k+=f,d(T,a=D.belongings[A],f);for(C=D.deltaWithOwnCommunity(v,k,E,T.get(s)||0,s),x=s,y=0;y<T.size;y++)(a=T.dense[y])!==s&&(S=T.vals[y],j++,h(x,s,a,M=D.delta(v,k,E,S,a),C)&&(C=M,x=a));if(C<0){if((x=D.isolate(v,k,E))===s)continue}else{if(x===s)continue;D.move(v,k,E,x)}N=!0,$++}_.push($),L=N||L}L&&D.zoomOut()}return{index:D,deltaComputations:j,nodesVisited:O,moves:z}}function g(r,i,o,s){if(!t(o))throw new Error("graphology-communities-louvain: the given graph is not a valid graphology instance.");var a=n(o);if("mixed"===a)throw new Error("graphology-communities-louvain: cannot run the algorithm on a true mixed graph.");s=e(s,u);var c=0;if(0===o.size){if(r)return void o.forEachNode(function(e){o.setNodeAttribute(e,s.nodeCommunityAttribute,c++)});var d={};return o.forEachNode(function(e){d[e]=c++}),i?{communities:d,count:o.order,deltaComputations:0,dendrogram:null,level:0,modularity:NaN,moves:null,nodesVisited:0,resolution:s.resolution}:d}var h=("undirected"===a?l:p)(i,o,s),g=h.index;if(!i)return r?void g.assign(s.nodeCommunityAttribute):g.collect();var m={count:g.C,deltaComputations:h.deltaComputations,dendrogram:g.dendrogram,level:g.level,modularity:g.modularity(),moves:h.moves,nodesVisited:h.nodesVisited,resolution:s.resolution};return r?(g.assign(s.nodeCommunityAttribute),m):(m.communities=g.collect(),m)}var m=g.bind(null,!1,!1);return m.assign=g.bind(null,!0,!1),m.detailed=g.bind(null,!1,!0),m.defaults=u,dn=m}()),gn=new it;function mn(e,t={}){gn.hasNode(e)||gn.addNode(e,t)}function fn(e,t,n,r={}){gn.hasEdge(e,t)||gn.addEdge(e,t,c(a({},r),{relationType:n}))}function yn(e,t){return gn.hasNode(e)?gn.outboundEdges(e).filter(e=>gn.getEdgeAttribute(e,"relationType")===t).map(e=>gn.target(e)):[]}function wn(){const e=gn.export();return Array.isArray(e.nodes)&&(e.nodes=e.nodes.map(e=>c(a({},e),{id:e.key}))),e}function bn(){return _t(gn)}function vn(){return Pt.degreeCentrality(gn)}function An(){return Xt(gn)}function In(){return pn.detailed(gn)}function kn(e,t,n,r={}){if(!gn.hasNode(e)||!gn.hasNode(t))return;gn.edges(e,t).some(e=>gn.getEdgeAttribute(e,"type")===n||gn.getEdgeAttribute(e,"relationType")===n)||gn.addEdge(e,t,c(a({},r),{relationType:n,type:n}))}const En=Object.freeze(Object.defineProperty({__proto__:null,addMemoryNode:mn,addTypedMemoryEdge:fn,ensureEdge:function(e,t,n,r={}){const i=gn.edges(e,t);let o=!1;for(const s of i)if(gn.getEdgeAttribute(s,"type")===n||gn.getEdgeAttribute(s,"relationType")===n){gn.mergeEdgeAttributes(s,c(a({},r),{relationType:n,type:n})),o=!0;break}o||gn.addEdge(e,t,c(a({},r),{relationType:n,type:n}))},getBetweennessCentrality:An,getCommunitiesLouvain:In,getDegreeCentrality:vn,getLinkedNodesByType:yn,getPageRankScores:bn,memoryGraph:gn,removeEdgeRelation:function(e,t,n){const r=gn.edges(e,t);for(const i of r)gn.getEdgeAttribute(i,"type")!==n&&gn.getEdgeAttribute(i,"relationType")!==n||gn.dropEdge(i)},safeAddEdge:kn,serializeGraph:wn,updateEdgeRelation:function(e,t,n,r,i={}){const o=gn.edges(e,t);for(const s of o)if(gn.getEdgeAttribute(s,"type")===n||gn.getEdgeAttribute(s,"relationType")===n){gn.dropEdge(s);break}gn.addEdge(e,t,c(a({},i),{relationType:r,type:r}))}},Symbol.toStringTag,{value:"Module"})),Sn=Symbol("Comlink.proxy"),xn=Symbol("Comlink.endpoint"),Cn=Symbol("Comlink.releaseProxy"),Mn=Symbol("Comlink.finalizer"),_n=Symbol("Comlink.thrown"),$n=e=>"object"==typeof e&&null!==e||"function"==typeof e,Dn=new Map([["proxy",{canHandle:e=>$n(e)&&e[Sn],serialize(e){const{port1:t,port2:n}=new MessageChannel;return Gn(e,t),[n,[n]]},deserialize:e=>(e.start(),Nn(e))}],["throw",{canHandle:e=>$n(e)&&_n in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Gn(e,t=globalThis,n=["*"]){t.addEventListener("message",function r(i){if(!i||!i.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,i.origin))return;const{id:o,type:s,path:a}=Object.assign({path:[]},i.data),c=(i.data.argumentList||[]).map(Rn);let u;try{const t=a.slice(0,-1).reduce((e,t)=>e[t],e),n=a.reduce((e,t)=>e[t],e);switch(s){case"GET":u=n;break;case"SET":t[a.slice(-1)[0]]=Rn(i.data.value),u=!0;break;case"APPLY":u=n.apply(t,c);break;case"CONSTRUCT":u=function(e){return Object.assign(e,{[Sn]:!0})}(new n(...c));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;Gn(e,n),u=function(e,t){return Wn.set(e,t),e}(t,[t])}break;case"RELEASE":u=void 0;break;default:return}}catch(d){u={value:d,[_n]:0}}Promise.resolve(u).catch(e=>({value:e,[_n]:0})).then(n=>{const[i,a]=qn(n);t.postMessage(Object.assign(Object.assign({},i),{id:o}),a),"RELEASE"===s&&(t.removeEventListener("message",r),Ln(t),Mn in e&&"function"==typeof e[Mn]&&e[Mn]())}).catch(e=>{const[n,r]=qn({value:new TypeError("Unserializable return value"),[_n]:0});t.postMessage(Object.assign(Object.assign({},n),{id:o}),r)})}),t.start&&t.start()}function Ln(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function Nn(e,t){const n=new Map;return e.addEventListener("message",function(e){const{data:t}=e;if(!t||!t.id)return;const r=n.get(t.id);if(r)try{r(t)}finally{n.delete(t.id)}}),Pn(e,n,[],t)}function Tn(e){if(e)throw new Error("Proxy has been released and is not useable")}function jn(e){return Hn(e,new Map,{type:"RELEASE"}).then(()=>{Ln(e)})}const On=new WeakMap,zn="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const t=(On.get(e)||0)-1;On.set(e,t),0===t&&jn(e)});function Pn(e,t,n=[],r=function(){}){let i=!1;const o=new Proxy(r,{get(r,s){if(Tn(i),s===Cn)return()=>{!function(e){zn&&zn.unregister(e)}(o),jn(e),t.clear(),i=!0};if("then"===s){if(0===n.length)return{then:()=>o};const r=Hn(e,t,{type:"GET",path:n.map(e=>e.toString())}).then(Rn);return r.then.bind(r)}return Pn(e,t,[...n,s])},set(r,o,s){Tn(i);const[a,c]=qn(s);return Hn(e,t,{type:"SET",path:[...n,o].map(e=>e.toString()),value:a},c).then(Rn)},apply(r,o,s){Tn(i);const a=n[n.length-1];if(a===xn)return Hn(e,t,{type:"ENDPOINT"}).then(Rn);if("bind"===a)return Pn(e,t,n.slice(0,-1));const[c,u]=Un(s);return Hn(e,t,{type:"APPLY",path:n.map(e=>e.toString()),argumentList:c},u).then(Rn)},construct(r,o){Tn(i);const[s,a]=Un(o);return Hn(e,t,{type:"CONSTRUCT",path:n.map(e=>e.toString()),argumentList:s},a).then(Rn)}});return function(e,t){const n=(On.get(t)||0)+1;On.set(t,n),zn&&zn.register(e,t,e)}(o,e),o}function Un(e){const t=e.map(qn);return[t.map(e=>e[0]),(n=t.map(e=>e[1]),Array.prototype.concat.apply([],n))];var n}const Wn=new WeakMap;function qn(e){for(const[t,n]of Dn)if(n.canHandle(e)){const[r,i]=n.serialize(e);return[{type:"HANDLER",name:t,value:r},i]}return[{type:"RAW",value:e},Wn.get(e)||[]]}function Rn(e){switch(e.type){case"HANDLER":return Dn.get(e.name).deserialize(e.value);case"RAW":return e.value}}function Hn(e,t,n,r){return new Promise(i=>{const o=new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-");t.set(o,i),e.start&&e.start(),e.postMessage(Object.assign({id:o},n),r)})}const Fn=Nn(new function(e){return new Worker(""+new URL("heavyTask.worker-BPgfcFPL.js",import.meta.url).href,{name:null==e?void 0:e.name})});u(null,null,function*(){try{const e=[[1,2,3],[4,5,6],[7,8,9]],t=[1,0,0];yield Fn.kMeans(e,2,2),yield Fn.cosineSimilarity([1,0,0],[0,1,0]),yield Fn.batchCosineSimilarity(e,t)}catch(e){}});var Bn,Qn,Vn,Jn,Kn,Yn={};!function(){if(Kn)return Yn;Kn=1;var e=ft(),t=function(){if(Qn)return Bn;Qn=1;var e=K(),t=qt();function n(){this.clear()}return n.prototype.clear=function(){this.items=[],this.offset=0,this.size=0},n.prototype.enqueue=function(e){return this.items.push(e),++this.size},n.prototype.dequeue=function(){if(this.size){var e=this.items[this.offset];return 2*++this.offset>=this.items.length&&(this.items=this.items.slice(this.offset),this.offset=0),this.size--,e}},n.prototype.peek=function(){if(this.size)return this.items[this.offset]},n.prototype.forEach=function(e,t){t=arguments.length>1?t:this;for(var n=this.offset,r=0,i=this.items.length;n<i;n++,r++)e.call(t,this.items[n],r,this)},n.prototype.toArray=function(){return this.items.slice(this.offset)},n.prototype.values=function(){var t=this.items,n=this.offset;return new e(function(){if(n>=t.length)return{done:!0};var e=t[n];return n++,{value:e,done:!1}})},n.prototype.entries=function(){var t=this.items,n=this.offset,r=0;return new e(function(){if(n>=t.length)return{done:!0};var e=t[n];return n++,{value:[r++,e],done:!1}})},"undefined"!=typeof Symbol&&(n.prototype[Symbol.iterator]=n.prototype.values),n.prototype.toString=function(){return this.toArray().join(",")},n.prototype.toJSON=function(){return this.toArray()},n.prototype.inspect=function(){var e=this.toArray();return Object.defineProperty(e,"constructor",{value:n,enumerable:!1}),e},"undefined"!=typeof Symbol&&(n.prototype[Symbol.for("nodejs.util.inspect.custom")]=n.prototype.inspect),n.from=function(e){var r=new n;return t(e,function(e){r.enqueue(e)}),r},n.of=function(){return n.from(arguments)},Bn=n}(),n=Jn?Vn:(Jn=1,Vn=function(e,t){var n=t.length;if(0!==n){var r=e.length;e.length+=n;for(var i=0;i<n;i++)e[r+i]=t[i]}});function r(t,r,i){if(!e(r))throw new Error("graphology-shortest-path: invalid graphology instance.");if(!r.hasNode(i))throw new Error('graphology-shortest-path: the "'+i+'" source node does not exist in the given graph.');i=""+i;var o=new Set,s={},a=0;s[i]=0;for(var c,u,d,h=[i];0!==h.length;){var l=[];for(c=0,u=h.length;c<u;c++)d=h[c],o.has(d)||(o.add(d),n(l,r[t](d)),s[d]=a);a++,h=l}return s}var i=r.bind(null,"outboundNeighbors"),o=r.bind(null,"neighbors");Yn.bidirectional=function(t,n,r){if(!e(t))throw new Error("graphology-shortest-path: invalid graphology instance.");if(arguments.length<3)throw new Error("graphology-shortest-path: invalid number of arguments. Expecting at least 3.");if(!t.hasNode(n))throw new Error('graphology-shortest-path: the "'+n+'" source node does not exist in the given graph.');if(!t.hasNode(r))throw new Error('graphology-shortest-path: the "'+r+'" target node does not exist in the given graph.');if((n=""+n)===(r=""+r))return[n];var i=t.inboundNeighbors.bind(t),o=t.outboundNeighbors.bind(t),s={},a={};s[n]=null,a[r]=null;var c,u,d,h,l,p,g,m,f=[n],y=[r],w=!1;e:for(;f.length&&y.length;)if(f.length<=y.length){for(c=f,f=[],l=0,g=c.length;l<g;l++)for(p=0,m=(d=o(u=c[l])).length;p<m;p++)if((h=d[p])in s||(f.push(h),s[h]=u),h in a){w=!0;break e}}else for(c=y,y=[],l=0,g=c.length;l<g;l++)for(p=0,m=(d=i(u=c[l])).length;p<m;p++)if((h=d[p])in a||(y.push(h),a[h]=u),h in s){w=!0;break e}if(!w)return null;for(var b=[];h;)b.unshift(h),h=s[h];for(h=a[b[b.length-1]];h;)b.push(h),h=a[h];return b.length?b:null},Yn.singleSource=function(t,n){if(!e(t))throw new Error("graphology-shortest-path: invalid graphology instance.");if(arguments.length<2)throw new Error("graphology-shortest-path: invalid number of arguments. Expecting at least 2.");if(!t.hasNode(n))throw new Error('graphology-shortest-path: the "'+n+'" source node does not exist in the given graph.');var r,i,o,s,a,c,u={},d={};for(u[n=""+n]=!0,d[n]=[n];Object.keys(u).length;)for(o in r=u,u={},r)for(a=0,c=(i=t.outboundNeighbors(o)).length;a<c;a++)d[s=i[a]]||(d[s]=d[o].concat(s),u[s]=!0);return d},Yn.singleSourceLength=i,Yn.undirectedSingleSourceLength=o,Yn.brandes=function(e,n){n=""+n;var r,i,o,s,a,c,u,d,h,l=[],p={},g={},m=e.nodes();for(c=0,d=m.length;c<d;c++)p[s=m[c]]=[],g[s]=0;var f={};g[n]=1,f[n]=0;for(var y=t.of(n);y.size;)for(s=y.dequeue(),l.push(s),r=f[s],i=g[s],u=0,h=(o=e.outboundNeighbors(s)).length;u<h;u++)(a=o[u])in f||(y.enqueue(a),f[a]=r+1),f[a]===r+1&&(g[a]+=i,p[a].push(s));return[l,p,g]}}();class Zn{static summarize(e,t=200,n=!0){return n&&e.content.length<=t?e.content:e.content.substring(0,t)+"..."}static shouldCompress(e){return Date.now()-new Date(e.updatedAt).getTime()>6048e5||(e.relevanceScore||0)<.3}}const Xn={},er={qualityMetrics:{totalMemories:0,lowQualityCount:0,averageQuality:0,lastQualityCheck:0},GEMINI_2_5_CONTEXT_LIMITS:{GEMINI_2_5_FLASH_PREVIEW:1e6,GEMINI_2_5_FLASH_LITE:1e6,GEMINI_2_0_FLASH:1e6,DEFAULT:1e6},trackMemoryQuality:e=>{const t=er.analyzeMemoryQuality(e.content);er.qualityMetrics.totalMemories++,"low"===t.quality&&er.qualityMetrics.lowQualityCount++;const n="high"===t.quality?3:"medium"===t.quality?2:1;er.qualityMetrics.averageQuality=(er.qualityMetrics.averageQuality*(er.qualityMetrics.totalMemories-1)+n)/er.qualityMetrics.totalMemories,er.qualityMetrics.lastQualityCheck=Date.now()},getMemoryQualityMetrics:()=>{const e=er.qualityMetrics.totalMemories>0?er.qualityMetrics.lowQualityCount/er.qualityMetrics.totalMemories:0;return{totalMemories:er.qualityMetrics.totalMemories,averageQuality:er.qualityMetrics.averageQuality,lowQualityCount:er.qualityMetrics.lowQualityCount,compressionEfficiency:1-e,contextualRelevance:Math.max(.5,er.qualityMetrics.averageQuality/3),memoryDiversity:Math.min(1,er.qualityMetrics.totalMemories/20)}},getGeminiOptimizedContextWindowSize:(e,t,n)=>{const r=.8*(er.GEMINI_2_5_CONTEXT_LIMITS[e]||er.GEMINI_2_5_CONTEXT_LIMITS.DEFAULT),i=.6+.4*n,o=t>100?.5:t>50?.7:t>20?.85:t>10?.95:1;return Math.round(r*i*o)},estimateTokenCount:e=>{const t=(e.match(/[a-zA-Z0-9\s]/g)||[]).length,n=e.length-t;return Math.ceil(t/4+n/2)},clusterMemoriesByTopic:e=>{const t={};return e.forEach(e=>{try{const n=JSON.parse(e);if(n&&"object"==typeof n){let r="general",i=1;if(n.coreLink){const e=n.coreLink.toLowerCase();e.includes("combat")||e.includes("battle")||e.includes("fight")||e.includes("attack")||e.includes("defend")||e.includes("weapon")?(r="combat",i=2):e.includes("social")||e.includes("conversation")||e.includes("dialogue")||e.includes("talk")||e.includes("speak")||e.includes("npc")?(r="social",i=2):e.includes("exploration")||e.includes("discovery")||e.includes("investigation")||e.includes("explore")||e.includes("search")||e.includes("look")?(r="exploration",i=2):e.includes("quest")||e.includes("mission")||e.includes("objective")||e.includes("task")||e.includes("goal")?(r="quest",i=2):e.includes("character")||e.includes("development")||e.includes("growth")||e.includes("emotion")||e.includes("feeling")||e.includes("relationship")?(r="character",i=1.5):(e.includes("world")||e.includes("setting")||e.includes("environment")||e.includes("location")||e.includes("place"))&&(r="world",i=1.5)}if(Array.isArray(n.plotHooks)&&n.plotHooks.length>0){const e=n.plotHooks.join(" ").toLowerCase();e.includes("mystery")||e.includes("secret")||e.includes("hidden")?(r="mystery",i=2.5):e.includes("danger")||e.includes("threat")||e.includes("enemy")?(r="danger",i=2.5):(e.includes("treasure")||e.includes("reward")||e.includes("loot"))&&(r="reward",i=2)}if(n.npcIntent&&""!==String(n.npcIntent).trim()){const e=String(n.npcIntent).toLowerCase();e.includes("hostile")||e.includes("enemy")||e.includes("attack")?(r="conflict",i=2.5):(e.includes("friendly")||e.includes("help")||e.includes("ally"))&&(r="alliance",i=2)}if(n.majorChanges&&""!==String(n.majorChanges).trim()){const e=String(n.majorChanges).toLowerCase();e.includes("death")||e.includes("loss")||e.includes("failure")?(r="consequence",i=2.5):(e.includes("victory")||e.includes("success")||e.includes("achievement"))&&(r="achievement",i=2)}t[r]||(t[r]={topic:r,memories:[],relevanceScore:0,lastUpdated:Date.now()}),t[r].memories.push(e),t[r].relevanceScore+=i}}catch(n){t.general||(t.general={topic:"general",memories:[],relevanceScore:0,lastUpdated:Date.now()}),t.general.memories.push(e),t.general.relevanceScore+=.5}}),Object.values(t).sort((e,t)=>t.relevanceScore!==e.relevanceScore?t.relevanceScore-e.relevanceScore:t.lastUpdated-e.lastUpdated)},predictNextTurnMemories:(e,t)=>{const n=e.toLowerCase().split(/\s+/),r=er.clusterMemoriesByTopic(t),i=[];n.some(e=>["fight","attack","defend","battle","kill","weapon"].includes(e))&&i.push("combat"),n.some(e=>["talk","speak","ask","tell","convince","persuade","npc"].includes(e))&&i.push("social"),n.some(e=>["explore","search","investigate","look","examine","move","go"].includes(e))&&i.push("exploration"),n.some(e=>["quest","mission","objective","goal","task"].includes(e))&&i.push("quest"),0===i.length&&i.push("general");const o=[];i.forEach(e=>{const t=r.find(t=>t.topic===e);t&&o.push(...t.memories.slice(0,2))});const s=[];for(const a of o){let e=!1;for(const t of s)if(a.length>100&&t.length>100&&a.substring(0,100)===t.substring(0,100)){e=!0;break}e||s.push(a)}return s.slice(0,4)},pickFromHistory:(e,t=3)=>{const n=e.filter(e=>"story"===e.type&&e.gameSummaryForMemory).slice(-30),r=n.map((e,t)=>{let r=1,i={turn:n.length-t,hasPlotHooks:!1,hasMajorChanges:!1,hasNewElements:!1,hasNpcIntent:!1,recency:1-t/n.length,importanceDecay:1,contextualRelevance:1};try{const t=JSON.parse(e.gameSummaryForMemory);if(t&&"object"==typeof t){const e=Array.isArray(t.plotHooks)?t.plotHooks.length:0;i.hasPlotHooks=e>0,r+=.15*e;const n=t.majorChanges&&""!==String(t.majorChanges).trim()?1:0;i.hasMajorChanges=n>0,r+=.4*n;const o=Array.isArray(t.newElements)?t.newElements.length:0;i.hasNewElements=o>0,r+=.2*o;const s=t.npcIntent&&""!==String(t.npcIntent).trim()?1:0;i.hasNpcIntent=s>0,r+=.25*s;if(r+=.3*(t.coreLink&&""!==String(t.coreLink).trim()?1:0),t.ideas&&"object"==typeof t.ideas){r+=.1*Object.values(t.ideas).filter(e=>e&&""!==String(e).trim()).length}t.relevanceScore&&(r+=t.relevanceScore),t.recencyScore&&(r+=t.recencyScore);const a=i.turn;i.importanceDecay=Math.max(.5,1-.02*a),r*=i.importanceDecay}}catch(o){}r+=.2*i.recency;return r+=.1*[i.hasPlotHooks,i.hasMajorChanges,i.hasNewElements,i.hasNpcIntent].filter(Boolean).length,{text:e.gameSummaryForMemory,score:r,metadata:i}});r.sort((e,t)=>t.score-e.score);const i=r.slice(0,t).map(e=>e.text);i.forEach(e=>{try{const t=JSON.parse(e);er.trackMemoryQuality(t)}catch(t){er.trackMemoryQuality({id:"",content:e,tags:[],createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString()})}});const o=[];for(const s of i){let e=!1;for(const t of o)if(s.length>100&&t.length>100&&s.substring(0,100)===t.substring(0,100)){e=!0;break}e||o.push(s)}return o},pickFromHistoryWithContext:(e,t,n=3)=>{const r=e.filter(e=>"story"===e.type&&e.gameSummaryForMemory).slice(-30),i=t.toLowerCase().split(/\s+/),o=r.map((e,t)=>{let n=1,o={turn:r.length-t,hasPlotHooks:!1,hasMajorChanges:!1,hasNewElements:!1,hasNpcIntent:!1,recency:1-t/r.length,importanceDecay:1,contextualRelevance:1};try{const t=JSON.parse(e.gameSummaryForMemory);if(t&&"object"==typeof t){const e=Array.isArray(t.plotHooks)?t.plotHooks.length:0;o.hasPlotHooks=e>0,n+=.15*e;const r=t.majorChanges&&""!==String(t.majorChanges).trim()?1:0;o.hasMajorChanges=r>0,n+=.4*r;const s=Array.isArray(t.newElements)?t.newElements.length:0;o.hasNewElements=s>0,n+=.2*s;const a=t.npcIntent&&""!==String(t.npcIntent).trim()?1:0;o.hasNpcIntent=a>0,n+=.25*a;if(n+=.3*(t.coreLink&&""!==String(t.coreLink).trim()?1:0),t.ideas&&"object"==typeof t.ideas){n+=.1*Object.values(t.ideas).filter(e=>e&&""!==String(e).trim()).length}const c=JSON.stringify(t).toLowerCase(),u=i.filter(e=>c.includes(e)&&e.length>2).length;o.contextualRelevance=Math.min(2,1+.3*u),n*=o.contextualRelevance;const d=o.turn;o.importanceDecay=Math.max(.5,1-.02*d),n*=o.importanceDecay,t.relevanceScore&&(n+=t.relevanceScore),t.recencyScore&&(n+=t.recencyScore)}}catch(s){}n+=.2*o.recency;return n+=.1*[o.hasPlotHooks,o.hasMajorChanges,o.hasNewElements,o.hasNpcIntent].filter(Boolean).length,{text:e.gameSummaryForMemory,score:n,metadata:o}});o.sort((e,t)=>t.score-e.score);const s=o.slice(0,n).map(e=>e.text);s.forEach(e=>{try{const t=JSON.parse(e);er.trackMemoryQuality(t)}catch(t){er.trackMemoryQuality({id:"",content:e,tags:[],createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString()})}});const a=[];for(const c of s){let e=!1;for(const t of a)if(c.length>100&&t.length>100&&c.substring(0,100)===t.substring(0,100)){e=!0;break}e||a.push(c)}return a},prepareGeminiOptimizedMemories:(e,t,n=0)=>{const r=n||er.getGeminiOptimizedContextWindowSize(t,e.length,.7),i=er.optimizeMemoryForLongGame(e,r),o=[];let s=0;i.forEach((e,t)=>{const n=er.estimateTokenCount(e);s+n<=r&&(o.push({role:"user",content:`Memory ${t+1}: ${e}`}),s+=n)});const a=e.length>0?i.length/e.length:1;return{systemInstruction:`Previous game memories (${i.length} items): Use these memories to maintain story consistency and continuity.`,contents:o,totalTokens:s,memoryCount:i.length,compressionRatio:a}},compressMemory:(e,t=500)=>{try{const n=JSON.parse(e);if(n&&"object"==typeof n){const r=e.length,i=[],o={};if(n.coreLink&&(o.coreLink=n.coreLink,i.push("coreLink")),Array.isArray(n.plotHooks)&&n.plotHooks.length>0&&(o.plotHooks=n.plotHooks.slice(0,2),i.push("plotHooks")),n.majorChanges&&(o.majorChanges=n.majorChanges,i.push("majorChanges")),n.npcIntent&&(o.npcIntent=n.npcIntent,i.push("npcIntent")),Array.isArray(n.newElements)&&n.newElements.length>0&&(o.newElements=n.newElements.slice(0,3),i.push("newElements")),n.ideas&&"object"==typeof n.ideas){const e={};Object.keys(n.ideas).slice(0,2).forEach(t=>{n.ideas[t]&&""!==String(n.ideas[t]).trim()&&(e[t]=n.ideas[t])}),Object.keys(e).length>0&&(o.ideas=e,i.push("ideas"))}const s=JSON.stringify(o,null,2),a=s.length;if(a>t){const e=er.truncateMemoryStrings(o,t),n=JSON.stringify(e,null,2);return{compressedText:n,originalLength:r,compressedLength:n.length,compressionRatio:n.length/r,preservedElements:i}}return{compressedText:s,originalLength:r,compressedLength:a,compressionRatio:a/r,preservedElements:i}}}catch(n){const r=e.length>t?e.substring(0,t)+"...":e;return{compressedText:r,originalLength:e.length,compressedLength:r.length,compressionRatio:r.length/e.length,preservedElements:["raw_text"]}}return{compressedText:e,originalLength:e.length,compressedLength:e.length,compressionRatio:1,preservedElements:["original"]}},truncateMemoryStrings:(e,t)=>{const n={};let r=0;for(const[i,o]of Object.entries(e)){if("string"==typeof o){const e=t-r-50;e>20&&(n[i]=o.length>e?o.substring(0,e)+"...":o,r+=n[i].length)}else if(Array.isArray(o)){t-r-50>20&&(n[i]=o.map(e=>"string"==typeof e&&e.length>50?e.substring(0,50)+"...":e),r+=JSON.stringify(n[i]).length)}else if("object"==typeof o&&null!==o){const e=t-r-50;e>20&&(n[i]=er.truncateMemoryStrings(o,e),r+=JSON.stringify(n[i]).length)}else n[i]=o,r+=String(o).length;if(r>=t)break}return n},analyzeMemoryQuality:e=>{let t;try{t=JSON.parse(e)}catch(o){return{quality:"low",factors:["Memory text is not valid JSON"],suggestions:["Ensure memory is stored as a valid JSON object"],compressionPotential:1}}const n=["coreLink","plotHooks","npcIntent"],r=n.filter(e=>t[e]&&(!Array.isArray(t[e])||t[e].length>0)),i=["majorChanges","newElements","ideas"].filter(e=>t[e]&&(!Array.isArray(t[e])||t[e].length>0));return r.length>=2&&i.length>=1?{quality:"high",factors:[],suggestions:[],compressionPotential:.1}:r.length>=1&&i.length>=1?{quality:"medium",factors:[],suggestions:[],compressionPotential:.2}:{quality:"low",factors:[`Missing required fields: ${n.filter(e=>!r.includes(e)).join(", ")}`],suggestions:["Ensure at least one required field and one optional field are present and non-empty"],compressionPotential:.8}},autoCorrectMemory:(e,t)=>{const n={};n.coreLink=e.coreLink||"Connects to core game elements",n.plotHooks=Array.isArray(e.plotHooks)?e.plotHooks.slice(0,3):[],n.npcIntent=e.npcIntent||"",n.newElements=Array.isArray(e.newElements)?e.newElements.slice(0,3):[],n.majorChanges=e.majorChanges||"",n.ideas=e.ideas||{world:"",psych:"",plot:"",sensory:""},"string"==typeof n.coreLink&&n.coreLink.length>100&&(n.coreLink=n.coreLink.substring(0,100)+"..."),"string"==typeof n.npcIntent&&n.npcIntent.length>80&&(n.npcIntent=n.npcIntent.substring(0,80)+"..."),"string"==typeof n.majorChanges&&n.majorChanges.length>60&&(n.majorChanges=n.majorChanges.substring(0,60)+"...");return JSON.stringify(n,null,2)},optimizeMemoryForLongGame:(e,t=2e3)=>{const n=[];let r=0;const i=e.map(e=>{const t=er.analyzeMemoryQuality(e);return{memory:e,score:"high"===t.quality?3:"medium"===t.quality?2:1,analysis:t}}).sort((e,t)=>t.score-e.score);for(const{memory:o,analysis:s}of i){const e=t-r;if(e<=0)break;if(s.compressionPotential>.3){const t=er.compressMemory(o,e);t.compressedLength<=e&&(n.push(t.compressedText),r+=t.compressedLength)}else o.length<=e&&(n.push(o),r+=o.length)}return n},getAdaptiveContextWindowSize:(e,t)=>{const n=.5+.5*t,r=e>50?.7:e>20?.85:e>10?.95:1;return Math.round(2e3*n*r)},resetQualityMetrics:()=>{er.qualityMetrics={totalMemories:0,lowQualityCount:0,averageQuality:0,lastQualityCheck:0}},consolidateMemories:e=>{if(e.length<=1)return{consolidatedMemories:e,summary:"No consolidation needed",compressionRatio:1,preservedElements:["original"]};let t=[];if(e.every(e=>{try{const t=JSON.parse(e);return Array.isArray(t.embedding)&&t.embedding.length>0}catch(t){return!1}})){const n=.85,r=new Array(e.length).fill(!1);for(let i=0;i<e.length;++i){if(r[i])continue;const o=JSON.parse(e[i]),s=[e[i]];r[i]=!0;for(let t=i+1;t<e.length;++t){if(r[t])continue;const i=JSON.parse(e[t]);er.cosineSimilarity(o.embedding,i.embedding)>=n&&(s.push(e[t]),r[t]=!0)}t.push({topic:"semantic",memories:s,importance:1,recency:1,embedding:o.embedding})}}else t=[],e.forEach(e=>{try{const n=JSON.parse(e);let r="general",i=1,o=1;if(n.majorChanges&&""!==String(n.majorChanges).trim()?(r="major_changes",i=3):Array.isArray(n.plotHooks)&&n.plotHooks.length>0?(r="plot_hooks",i=2):n.npcIntent&&""!==String(n.npcIntent).trim()&&(r="npc_intentions",i=2),n.timestamp){const e=(Date.now()-new Date(n.timestamp).getTime())/864e5;o=Math.max(.1,1-e/30)}let s=t.find(e=>e.topic===r);s||(s={topic:r,memories:[],importance:0,recency:0},t.push(s)),s.memories.push(e),s.importance=Math.max(s.importance,i),s.recency=Math.max(s.recency,o)}catch(n){let r=t.find(e=>"general"===e.topic);r||(r={topic:"general",memories:[],importance:1,recency:1},t.push(r)),r.memories.push(e)}});const n=[],r=[];t.forEach(e=>{if(1===e.memories.length)n.push(e.memories[0]),r.push("single_memory");else{const t=e.memories.map(e=>{try{const t=JSON.parse(e);return t.majorChanges?`Major event: ${t.majorChanges}`:Array.isArray(t.plotHooks)&&t.plotHooks.length>0?`Plot hooks: ${t.plotHooks.join(", ")}`:t.npcIntent?`NPC intent: ${t.npcIntent}`:""}catch(t){return""}}).filter(Boolean).slice(0,2).join(" ");n.push(t),r.push(`consolidated_${e.topic}`)}}),n.sort((e,n)=>{const r=t.find(t=>t.memories.includes(e)||e.includes(t.topic)),i=t.find(e=>e.memories.includes(n)||n.includes(e.topic)),o=((null==r?void 0:r.importance)||1)*((null==r?void 0:r.recency)||1);return((null==i?void 0:i.importance)||1)*((null==i?void 0:i.recency)||1)-o});const i=e.length>0?n.length/e.length:1,o=`Consolidated ${e.length} memories into ${n.length} groups (${Math.round(100*(1-i))}% reduction)`,s=e.filter(e=>er.isPinnedMemory(e)).filter(e=>!n.includes(e));return s.length>0&&n.push(...s),{consolidatedMemories:n,summary:o,compressionRatio:i,preservedElements:r}},cosineSimilarity:(e,t)=>{if(!Array.isArray(e)||!Array.isArray(t)||e.length!==t.length)return 0;let n=0,r=0,i=0;for(let o=0;o<e.length;o++)n+=e[o]*t[o],r+=e[o]*e[o],i+=t[o]*t[o];return r&&i?n/(Math.sqrt(r)*Math.sqrt(i)):0},refreshMemories:(e,t,n=[])=>{const r=[];let i=0,o=0;new Set(n),e.forEach(e=>{if(er.isPinnedMemory(e))r.push(e);else try{const s=JSON.parse(e);if(!s||"object"!=typeof s)return void r.push(e);const a=er.assessMemoryQuality(e);let c=!1,u="";if(s.timestamp){const e=Date.now()-new Date(s.timestamp).getTime();e/864e5>7&&(c=!0,u="age")}if(a<.6&&(c=!0,u="quality"),(null==t?void 0:t.currentLocation)&&s.location&&s.location!==t.currentLocation&&(c=!0,u="location"),(null==t?void 0:t.currentNPCs)&&Array.isArray(t.currentNPCs)){const e=s.npcs||[];e.some(e=>!t.currentNPCs.includes(e))&&(c=!0,u="npcs")}if(n.length>0){n.filter(t=>t===e).length>1&&(c=!0,u="redundancy")}if(c){const e=er.refreshSingleMemory(s,t,u);r.push(e),i++;const n=er.assessMemoryQuality(e);o+=n-a}else r.push(e)}catch(s){r.push(e)}});const s=i>0?o/i:0,a=`Refreshed ${i} memories (${Math.round(100*s)}% avg quality improvement)`;return{refreshedMemories:r,summary:a,refreshCount:i,qualityImprovement:s}},refreshSingleMemory:(e,t,n)=>{const r=c(a({},e),{timestamp:(new Date).toISOString(),refreshed:!0,refreshReason:n,originalTimestamp:e.timestamp});if((null==t?void 0:t.currentLocation)&&(r.location=t.currentLocation),(null==t?void 0:t.currentNPCs)&&Array.isArray(t.currentNPCs)&&(r.npcs=t.currentNPCs),Array.isArray(e.plotHooks)&&e.plotHooks.length>0&&(r.plotHooks=e.plotHooks.map(e=>(null==t?void 0:t.currentLocation)?`${e} (Location: ${t.currentLocation})`:e)),e.majorChanges&&""!==String(e.majorChanges).trim()){const n=(null==t?void 0:t.currentTurn)?`(Turn ${t.currentTurn})`:"";r.majorChanges=`${e.majorChanges} ${n}`.trim()}return e.npcIntent&&""!==String(e.npcIntent).trim()&&((null==t?void 0:t.currentNPCs)&&t.currentNPCs.length>0?r.npcIntent=`${e.npcIntent} (Active NPCs: ${t.currentNPCs.join(", ")})`:r.npcIntent=e.npcIntent),JSON.stringify(r,null,2)},assessMemoryQuality:e=>{try{const t=JSON.parse(e);if(!t||"object"!=typeof t)return.3;let n=.5;if(t.majorChanges&&""!==String(t.majorChanges).trim()&&(n+=.2),Array.isArray(t.plotHooks)&&t.plotHooks.length>0&&(n+=.15),t.npcIntent&&""!==String(t.npcIntent).trim()&&(n+=.15),Array.isArray(t.newElements)&&t.newElements.length>0&&(n+=.1),t.timestamp){const e=(Date.now()-new Date(t.timestamp).getTime())/864e5;n+=.1*Math.max(0,1-e/30)}return t.refreshed&&(n+=.1),Math.min(1,n)}catch(t){return.3}},detectStoryContinuity:(e,t)=>{const n=[],r=[],i=[],o=[];let s=1,a=1;try{const c=er.extractStoryElements(e);let u=0,d=t.length;t.forEach((e,t)=>{try{const t=JSON.parse(e);if(!t||"object"!=typeof t)return;const a=er.extractMemoryElements(t),d=er.checkElementContinuity(c,a);if(d.score<.8){const e=er.addContextToIssue(d.issue,t,c);n.push(e),r.push(d.suggestion),s=Math.min(s,d.score);const i=er.generateRecoveryAction(d.issue,t);i&&o.push(i)}(t.majorChanges||Array.isArray(t.plotHooks)&&t.plotHooks.length>0)&&i.push(e),u++}catch(a){const t=er.attemptMemoryRecovery(e);t&&(i.push(t),o.push("Recovered corrupted memory"))}});a*=u/Math.max(d,1);const h=er.checkTemporalContinuity(t);h.score<.8&&(n.push(...h.issues),r.push(...h.suggestions),s=Math.min(s,h.score),h.issues.forEach(e=>{const t=er.generateTemporalRecoveryAction(e);t&&o.push(t)}));const l=er.checkCharacterContinuity(t);if(l.score<.8&&(n.push(...l.issues),r.push(...l.suggestions),s=Math.min(s,l.score),l.issues.forEach(e=>{const t=er.generateCharacterRecoveryAction(e);t&&o.push(t)})),n.length>0){a*=Math.max(.3,1-.1*n.length)}}catch(c){n.push("Error occurred during continuity analysis"),r.push("Check memory format and try again"),o.push("Restart continuity analysis"),a=.1}return{continuityScore:s,continuityIssues:n,suggestedFixes:r,criticalMemories:i,confidence:Math.max(a,.1),recoveryActions:o}},addContextToIssue:(e,t,n)=>{const r=[];return t.timestamp&&r.push(`Memory timestamp: ${t.timestamp}`),n.characters.length>0&&r.push(`Current characters: ${n.characters.join(", ")}`),n.locations.length>0&&r.push(`Current locations: ${n.locations.join(", ")}`),`${e} [Context: ${r.join(" | ")}]`},generateRecoveryAction:(e,t)=>e.includes("Character inconsistency")?"Review and update character names in memory":e.includes("Location inconsistency")?"Verify location references in story context":e.includes("temporal")?"Check timeline consistency in story events":null,generateTemporalRecoveryAction:e=>e.includes("Large temporal gap")?"Add intermediate events to maintain story flow":e.includes("temporal inconsistency")?"Review event timeline for logical sequence":null,generateCharacterRecoveryAction:e=>e.includes("inconsistent development")?"Review character arc for logical progression":e.includes("character changed dramatically")?"Check for missing character development events":null,attemptMemoryRecovery:e=>{try{const t=e.match(/\{.*\}/);if(t){const e=t[0],n=JSON.parse(e);if(n&&"object"==typeof n)return JSON.stringify(n)}const n=e.replace(/[{}"]/g,"").trim();if(n.length>10)return JSON.stringify({content:n,timestamp:(new Date).toISOString(),recovered:!0})}catch(t){return null}return null},extractStoryElements:e=>{const t={characters:[],locations:[],events:[],items:[],relationships:[]},n=["character","NPC","person","villain","hero","ally"],r=["location","place","area","room","building","city"],i=["event","happened","occurred","took place","action"],o=["item","object","weapon","tool","artifact"],s=["relationship","friend","enemy","ally","lover"];return e.split(/[.!?]+/).filter(e=>e.trim().length>0).forEach(e=>{const a=e.toLowerCase();if(n.some(e=>a.includes(e))){const n=e.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g);n&&t.characters.push(...n)}if(r.some(e=>a.includes(e))){const n=e.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g);n&&t.locations.push(...n)}if(i.some(e=>a.includes(e))&&t.events.push(e.trim()),o.some(e=>a.includes(e))){const n=e.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g);n&&t.items.push(...n)}s.some(e=>a.includes(e))&&t.relationships.push(e.trim())}),t.characters=[...new Set(t.characters)],t.locations=[...new Set(t.locations)],t.items=[...new Set(t.items)],t},extractMemoryElements:e=>{const t={characters:[],locations:[],events:[],items:[],relationships:[]};if(e.majorChanges){const n=er.extractStoryElements(e.majorChanges);Object.keys(t).forEach(e=>{t[e].push(...n[e])})}if(Array.isArray(e.plotHooks)&&e.plotHooks.forEach(e=>{const n=er.extractStoryElements(e);Object.keys(t).forEach(e=>{t[e].push(...n[e])})}),e.npcIntent){const n=er.extractStoryElements(e.npcIntent);Object.keys(t).forEach(e=>{t[e].push(...n[e])})}return Object.keys(t).forEach(e=>{t[e]=[...new Set(t[e])]}),t},checkElementContinuity:(e,t)=>{let n=1,r="",i="";const o=new Set(e.characters.map(e=>e.toLowerCase())),s=new Set(t.characters.map(e=>e.toLowerCase())),a=[...o].filter(e=>s.has(e)).length,c=o.size>0?a/o.size:1;c<.5&&(n=Math.min(n,c),r=`Character inconsistency: ${e.characters.join(", ")} vs ${t.characters.join(", ")}`,i="Review character names and ensure consistency across story elements");const u=new Set(e.locations.map(e=>e.toLowerCase())),d=new Set(t.locations.map(e=>e.toLowerCase())),h=[...u].filter(e=>d.has(e)).length,l=u.size>0?h/u.size:1;return l<.5&&(n=Math.min(n,l),r=`Location inconsistency: ${e.locations.join(", ")} vs ${t.locations.join(", ")}`,i="Verify location names and ensure spatial consistency"),{score:n,issue:r,suggestion:i}},checkTemporalContinuity:e=>{let t=1;const n=[],r=[],i=[];e.forEach(e=>{var t;try{const n=JSON.parse(e);n.timestamp&&i.push({timestamp:n.timestamp,content:n.majorChanges||(null==(t=n.plotHooks)?void 0:t[0])||"Unknown event"})}catch(n){}}),i.sort((e,t)=>new Date(e.timestamp).getTime()-new Date(t.timestamp).getTime());for(let o=1;o<i.length;o++){const e=(new Date(i[o].timestamp).getTime()-new Date(i[o-1].timestamp).getTime())/864e5;e>30&&(n.push(`Large temporal gap: ${Math.round(e)} days between events`),r.push("Consider adding intermediate events to maintain story flow"),t=Math.min(t,.8))}return{score:t,issues:n,suggestions:r}},checkCharacterContinuity:e=>{let t=1;const n=[],r=[],i=new Map;return e.forEach(e=>{try{const t=JSON.parse(e);if(t.npcIntent&&t.timestamp){er.extractStoryElements(t.npcIntent).characters.forEach(e=>{i.has(e)||i.set(e,[]),i.get(e).push({timestamp:t.timestamp,intent:t.npcIntent})})}}catch(t){}}),i.forEach((e,i)=>{if(e.length>1){const o=e.slice(-3);o.some((e,t)=>{if(0===t)return!1;const n=o[t-1];return(new Date(e.timestamp).getTime()-new Date(n.timestamp).getTime())/864e5<1&&e.intent!==n.intent})&&(n.push(`Character ${i} has inconsistent development`),r.push(`Review ${i}'s character arc for consistency`),t=Math.min(t,.7))}}),{score:t,issues:n,suggestions:r}},preserveCriticalMemories:(e,t)=>{const n=[],r=[];let i=0;e.forEach(e=>{try{const o=JSON.parse(e);if(!o||"object"!=typeof o)return void n.push(e);const s=er.assessMemoryCriticality(o,t);if(s>=.8){const e=er.enhanceCriticalMemory(o,t);n.push(e),r.push(e),i++}else if(s>=.6){const e=er.enhanceMemory(o,t);n.push(e)}else n.push(e)}catch(o){n.push(e)}});return{preservedMemories:n,backupMemories:r,preservationSummary:`Preserved ${i} critical memories with enhanced metadata`,criticalCount:i}},assessMemoryCriticality:(e,t)=>{let n=0;if(e.majorChanges&&""!==String(e.majorChanges).trim()&&(n+=.4),Array.isArray(e.plotHooks)&&e.plotHooks.length>0&&(n+=.3),e.npcIntent&&""!==String(e.npcIntent).trim()&&(n+=.2),e.majorChanges&&(e.majorChanges.toLowerCase().includes("death")||e.majorChanges.toLowerCase().includes("killed")||e.majorChanges.toLowerCase().includes("died"))&&(n+=.3),e.majorChanges&&(e.majorChanges.toLowerCase().includes("location")||e.majorChanges.toLowerCase().includes("discovered")||e.majorChanges.toLowerCase().includes("found"))&&(n+=.2),e.timestamp){const t=(Date.now()-new Date(e.timestamp).getTime())/864e5;n+=.2*Math.max(0,1-t/7)}if((null==t?void 0:t.currentLocation)&&e.location===t.currentLocation&&(n+=.1),(null==t?void 0:t.currentNPCs)&&Array.isArray(t.currentNPCs)){(e.npcs||[]).some(e=>t.currentNPCs.includes(e))&&(n+=.1)}return Math.min(1,n)},enhanceCriticalMemory:(e,t)=>{const n=c(a({},e),{critical:!0,preservationTimestamp:(new Date).toISOString(),preservationReason:er.getPreservationReason(e),gameStateSnapshot:{turn:(null==t?void 0:t.currentTurn)||0,location:(null==t?void 0:t.currentLocation)||"unknown",npcs:(null==t?void 0:t.currentNPCs)||[],timestamp:(new Date).toISOString()}});return e.majorChanges&&(n.relatedElements=er.extractRelatedElements(e.majorChanges)),n.importanceMarkers=er.generateImportanceMarkers(e),JSON.stringify(n,null,2)},enhanceMemory:(e,t)=>{const n=c(a({},e),{enhanced:!0,enhancementTimestamp:(new Date).toISOString(),gameContext:{turn:(null==t?void 0:t.currentTurn)||0,location:(null==t?void 0:t.currentLocation)||"unknown"}});return JSON.stringify(n,null,2)},getPreservationReason:e=>e.majorChanges&&e.majorChanges.toLowerCase().includes("death")?"character_death":Array.isArray(e.plotHooks)&&e.plotHooks.length>0?"plot_hook":e.majorChanges?"major_change":e.npcIntent?"npc_intent":"general_importance",extractRelatedElements:e=>{const t={characters:[],locations:[],items:[],events:[]};return e.split(/[.!?]+/).filter(e=>e.trim().length>0).forEach(e=>{const n=e.toLowerCase(),r=e.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g);r&&t.characters.push(...r);const i=e.match(/(?:in|at|to)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g);i&&t.locations.push(...i.map(e=>e.replace(/^(in|at|to)\s+/,"")));const o=e.match(/(?:with|using|found)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g);o&&t.items.push(...o.map(e=>e.replace(/^(with|using|found)\s+/,""))),(n.includes("happened")||n.includes("occurred")||n.includes("took place"))&&t.events.push(e.trim())}),t.characters=[...new Set(t.characters)],t.locations=[...new Set(t.locations)],t.items=[...new Set(t.items)],t},generateImportanceMarkers:e=>{const t=[];if(e.majorChanges){const n=e.majorChanges.toLowerCase();(n.includes("death")||n.includes("killed")||n.includes("died"))&&t.push("character_death"),(n.includes("location")||n.includes("discovered"))&&t.push("location_change"),(n.includes("relationship")||n.includes("romance"))&&t.push("relationship_change"),(n.includes("quest")||n.includes("mission"))&&t.push("quest_progress"),(n.includes("item")||n.includes("artifact"))&&t.push("item_obtained")}return Array.isArray(e.plotHooks)&&e.plotHooks.length>0&&t.push("plot_hook"),e.npcIntent&&t.push("npc_intent"),t},fixCharacterConsistency:(e,t)=>{let n=!1;const r=a({},e);if(e.majorChanges&&(null==t?void 0:t.currentNPCs)){const i=t.currentNPCs;let o=e.majorChanges;i.forEach(e=>{[e,e.toLowerCase(),e.toUpperCase()].forEach(t=>{o.includes(t)&&!i.includes(t)&&(o=o.replace(new RegExp(t,"gi"),e),n=!0)})}),r.majorChanges=o}if(e.npcIntent&&(null==t?void 0:t.currentNPCs)){const i=t.currentNPCs;let o=e.npcIntent;i.forEach(e=>{[e,e.toLowerCase(),e.toUpperCase()].forEach(t=>{o.includes(t)&&!i.includes(t)&&(o=o.replace(new RegExp(t,"gi"),e),n=!0)})}),r.npcIntent=o}return{fixed:n,memory:r}},fixLocationConsistency:(e,t)=>{let n=!1;const r=a({},e);if(null==t?void 0:t.currentLocation){const i=t.currentLocation;if(e.majorChanges&&e.majorChanges.includes("location")){let t=e.majorChanges;t.includes(i)||(t=t.replace(/location[^,.]*/gi,i),r.majorChanges=t,n=!0)}e.location&&e.location!==i&&(r.location=i,n=!0)}return{fixed:n,memory:r}},fixTemporalConsistency:(e,t)=>{let n=!1;const r=a({},e);if(e.timestamp){(Date.now()-new Date(e.timestamp).getTime())/864e5>30&&(r.timestamp=(new Date).toISOString(),r.originalTimestamp=e.timestamp,n=!0)}return(null==t?void 0:t.currentTurn)&&!e.turn&&(r.turn=t.currentTurn,n=!0),{fixed:n,memory:r}},applyContinuityFixes:(e,t,n)=>{const r=[],i=[];let o=0;return t.forEach(t=>{try{const s=JSON.parse(t);if(!s||"object"!=typeof s)return void r.push(t);let a=!1,c=s;if(e.continuityIssues.some(e=>e.includes("Character inconsistency"))){const e=er.fixCharacterConsistency(s,n);e.fixed&&(c=e.memory,a=!0,i.push("character_consistency"))}if(e.continuityIssues.some(e=>e.includes("Location inconsistency"))){const e=er.fixLocationConsistency(s,n);e.fixed&&(c=e.memory,a=!0,i.push("location_consistency"))}if(e.continuityIssues.some(e=>e.includes("temporal"))){const e=er.fixTemporalConsistency(s,n);e.fixed&&(c=e.memory,a=!0,i.push("temporal_consistency"))}a?(c.fixed=!0,c.fixTimestamp=(new Date).toISOString(),r.push(JSON.stringify(c,null,2)),o++):r.push(t)}catch(s){r.push(t)}}),{fixedMemories:r,fixCount:o,fixesApplied:[...new Set(i)]}},summarizeMemory:(e,t=200)=>e.length<=t?e:e.substring(0,t)+"...",summarizeCriticalLongTermMemories:e=>{const t=e.map(e=>{try{return JSON.parse(e)}catch(t){return null}}).filter(e=>e&&(e.majorChanges||Array.isArray(e.plotHooks)&&e.plotHooks.length>0||e.npcIntent&&""!==String(e.npcIntent).trim())),n=[];for(const r of t)r.majorChanges&&n.push(`- Major event: ${r.majorChanges}`),Array.isArray(r.plotHooks)&&r.plotHooks.length>0&&n.push(`- Plot hooks: ${r.plotHooks.join(", ")}`),r.npcIntent&&n.push(`- NPC intent: ${r.npcIntent}`);return n.slice(0,10).join("\n")},logMemoryQualityDashboard:(e,t=0,n=0,r=0)=>{const i={};e.forEach(e=>{try{const t=JSON.parse(e);let n="general";t.majorChanges&&""!==String(t.majorChanges).trim()?n="major_changes":Array.isArray(t.plotHooks)&&t.plotHooks.length>0?n="plot_hooks":t.npcIntent&&""!==String(t.npcIntent).trim()&&(n="npc_intentions"),i[n]=(i[n]||0)+1;const r=er.analyzeMemoryQuality(e).quality;"high"===r?0:"medium"===r?0:0}catch(t){}});e.length;Object.entries(i).forEach(([e,t])=>{})},_pinnedMemorySet:new Set,pinMemory:function(e){this._pinnedMemorySet.add(e)},unpinMemory:function(e){this._pinnedMemorySet.delete(e)},isPinnedMemory:function(e){try{const t=JSON.parse(e);if(t&&t.id&&this._pinnedMemorySet.has(t.id))return!0;const n="string"==typeof e?this._simpleHash(e):"";return this._pinnedMemorySet.has(n)}catch(t){const n="string"==typeof e?this._simpleHash(e):"";return this._pinnedMemorySet.has(n)}},_simpleHash:function(e){let t=5381;for(let n=0;n<e.length;n++)t=(t<<5)+t+e.charCodeAt(n);return t.toString()},selectMemoriesForContext:function(e,t,n="",r=4){const i=n.toLowerCase(),o=t.filter(e=>!i.includes(e.toLowerCase()));let s=[];if(e){const t=e.trim();gn.hasNode(t)&&(s=[...yn(t,"related"),...yn(t,"action")])}let a=[];s.length>0&&void 0!==gn&&(a=s.map(e=>gn.getNodeAttribute(e,"text")).filter(Boolean).filter(e=>o.includes(e)));let c=[];if(void 0!==gn){const e=gn.nodes().filter(e=>gn.getNodeAttribute(e,"topic")),t=new Set;for(const n of e){if(!gn.hasNode(n))continue;const e=yn(n,"cluster");for(const n of e){const e=gn.getNodeAttribute(n,"text");if(e&&o.includes(e)&&!t.has(e)&&(c.push(e),t.add(e),c.length>=r))break}if(c.length>=r)break}}let u=[];try{const e=bn(),t=vn(),n=An(),r=In(),i=r&&r.communities?r.communities:{},s={};Object.values(i).forEach(e=>{s[e]=(s[e]||0)+1});for(const a of o){const r=gn.nodes().find(e=>gn.getNodeAttribute(e,"text")===a);if(!r)continue;let o=0;if(e&&e[r]&&(o+=2*e[r]),t&&t[r]&&(o+=t[r]),n&&n[r]&&(o+=n[r]),i&&void 0!==i[r]){const e=i[r];o+=s[e]||1}u.push({text:a,score:o})}u.sort((e,t)=>t.score-e.score)}catch(l){u=o.map(e=>({text:e,score:0}))}let d=[...a];for(const p of c){if(d.length>=r)break;d.includes(p)||d.push(p)}for(const p of u.map(e=>e.text)){if(d.length>=r)break;d.includes(p)||d.push(p)}const h=[];for(const p of d){let e=!1;for(const t of h)if(p.length>100&&t.length>100&&p.substring(0,100)===t.substring(0,100)){e=!0;break}e||h.push(p)}return h.slice(0,r)},registerMemoryHook:(e,t)=>{Xn[e]||(Xn[e]=[]),Xn[e].push(t)},triggerMemoryHooks:(e,t)=>{(Xn[e]||[]).forEach(e=>e(t))},initDefaultHooks:()=>{er.registerMemoryHook("post-refresh",e=>{Zn.shouldCompress(e)&&(e.content=Zn.summarize(e),e.updatedAt=(new Date).toISOString())})}};function tr(e){const t=Date.now(),n=[];return gn.forEachNode((r,i)=>{let o=0;if(e.requiredTags&&e.requiredTags.length>0){if(!i.tags||!e.requiredTags.every(e=>i.tags.includes(e)))return;o+=2*e.requiredTags.length}let s=[],a=0;if(gn.outboundEdges(r).forEach(e=>{const t=gn.getEdgeAttribute(e,"relationType");t&&s.push(t);const n=gn.getEdgeAttribute(e,"confidence");n&&n>a&&(a=n)}),e.edgeTypes&&e.edgeTypes.length>0){if(!s.some(t=>e.edgeTypes.includes(t)))return;o+=2*e.edgeTypes.length}if(!(e.minConfidence&&a<e.minConfidence)){if(o+=3*a,e.maxAgeMs&&i.updatedAt){const n=t-new Date(i.updatedAt).getTime();if(n>e.maxAgeMs)return;o+=Math.max(0,1-n/e.maxAgeMs)}if(e.embeddingVector&&i.embedding&&Array.isArray(i.embedding)){const t=i.embedding.reduce((t,n,r)=>t+n*e.embeddingVector[r],0),n=Math.sqrt(i.embedding.reduce((e,t)=>e+t*t,0)),r=Math.sqrt(e.embeddingVector.reduce((e,t)=>e+t*t,0));o+=5*(n&&r?t/(n*r):0)}o+=.5*s.length,i.topic&&(o+=1),n.push({id:r,text:i.text,score:o,tags:i.tags,edgeTypes:s,confidence:a,updatedAt:i.updatedAt})}}),n.sort((e,t)=>t.score-e.score),e.limit?n.slice(0,e.limit):n}const nr=Object.freeze(Object.defineProperty({__proto__:null,MemoryManager:er,queryContextAdvanced:tr},Symbol.toStringTag,{value:"Module"}));let rr={};class ir{constructor(){this.semanticClusters=new Map,this.contextCache=new Map,this.expansionQueue=[],this.initializeSemanticClustering(),this.startPeriodicClustering();const e=this;globalThis.addVectorEntry=function(t){return u(this,null,function*(){yield x(t),t.gameId&&(yield e.onMemoryAdded(t.gameId))})}}static getInstance(){return ir.instance||(ir.instance=new ir),ir.instance}processMultiModalContent(e){return u(this,null,function*(){try{let t=e.content,n=a({},e.metadata);switch(e.type){case"text":t=this.enhanceTextContent(e.content);break;case"image":t=yield this.extractImageText(e.content),n.imageAnalysis=!0;break;case"audio":t=yield this.extractAudioText(e.content),n.audioAnalysis=!0;break;case"video":t=yield this.extractVideoContent(e.content),n.videoAnalysis=!0}const r=yield d(t);if(!r)return null;const i={id:e.id,gameId:e.metadata.gameId||"global",sourceDocumentId:e.id,sourceType:"codex",text_chunk:t,embedding:r,metadata:n,createdAt:(new Date).toISOString()};return yield w.table("vectorStore").add(i),i}catch(t){return null}})}contextAwareSearch(e,t,n,r){return u(this,null,function*(){var i;try{const o=this.enhanceQueryWithContext(e),s=yield d(o);if(!s)throw new Error("Failed to generate embedding for query");const u=tr({embeddingVector:s,requiredTags:e.context.recentTopics||[],edgeTypes:["emotion","goal","motivation","location","event-type","related","cause-effect"],minConfidence:.5,maxAgeMs:2592e6,limit:10});if(u.length>0)return u.map(e=>({id:e.id,text_chunk:e.text,score:e.score,metadata:{tags:e.tags,edgeTypes:e.edgeTypes,confidence:e.confidence,updatedAt:e.updatedAt},contextRelevance:e.score}));let l=yield this.getSemanticClusters(e.context.gameId),p=l.map(e=>({cluster:e,similarity:this.cosineSimilarity(s,e.centroid||[])}));(0===p.length||Math.max(...p.map(e=>e.similarity))<.5)&&(yield this.createSemanticClusters(e.context.gameId),l=yield this.getSemanticClusters(e.context.gameId),p=l.map(e=>({cluster:e,similarity:this.cosineSimilarity(s,e.centroid||[])})));const g=p.filter(e=>e.similarity>=.7).sort((e,t)=>t.similarity-e.similarity).slice(0,2).map(e=>e.cluster),m=new Set,f=[];for(const e of g)for(const t of e.entries||[])m.has(t.id)||(f.push(t),m.add(t.id));let y=[];if(f.length<3&&void 0!==gn)for(const t of f){if(!gn.hasNode(t.id))continue;const n=yn(t.id,"related");for(const t of n){const n=gn.getNodeAttributes(t);if(n&&n.id&&n.text_chunk&&n.embedding&&n.gameId===e.context.gameId&&n.sourceType&&n.sourceDocumentId&&!m.has(n.id)&&!y.find(e=>e.id===n.id)&&(y.push(n),m.add(n.id),f.length+y.length>=5))break}if(f.length+y.length>=5)break}g.length>0&&(yield w.analyticsInsights.add({gameId:e.context.gameId,timestamp:(new Date).toISOString(),clusterId:g[0].id,similarity:(null==(i=p.find(e=>e.cluster.id===g[0].id))?void 0:i.similarity)||0,entriesCount:g[0].entries.length,query:e.query}));const b=(yield h(o,t,this.getTopKForDepth(e.preferences.searchDepth),e.context.gameId,n,r)).filter(e=>!m.has(e.id)),v=[...f,...y].map(e=>({id:e.id,text_chunk:e.text_chunk,score:1,metadata:e.metadata,contextRelevance:1})),A=b.map(t=>c(a({},t),{contextRelevance:this.calculateContextRelevance(t,e.context)}));A.sort((e,t)=>{const n=.7*e.score+.3*e.contextRelevance;return.7*t.score+.3*t.contextRelevance-n});const I=this.applyFocusAreaFiltering(A,e.preferences.focusAreas);return[...v,...I]}catch(o){return[]}})}createSemanticClusters(e,t=3){return u(this,null,function*(){try{const n=yield w.table("vectorStore").where("gameId").equals(e).toArray();if(n.length<t)return[];const r=yield this.performClustering(n,t);return r.map((t,n)=>{const r=`cluster_${e}_${n}_${Date.now()}`,i=this.extractClusterKeywords(t.entries),o={id:r,name:`Cluster ${n+1}`,description:this.generateClusterDescription(t.entries,i),keywords:i,entries:t.entries,centroid:t.centroid,confidence:t.confidence,createdAt:new Date,lastUpdated:new Date,metadata:{entityCount:0,emotionProfile:{},plotThreads:[]}};return this.semanticClusters.set(r,o),o})}catch(n){return[]}})}suggestKnowledgeExpansion(e,t,n="user_query"){return u(this,null,function*(){try{const r=yield this.analyzeKnowledgeGaps(e,t),i=yield this.generateSourceSuggestions(r,e),o=this.determineExpansionPriority(n,r),s={id:`expansion_${Date.now()}`,trigger:n,query:e,suggestedSources:i,priority:o,status:"pending",createdAt:new Date};return this.expansionQueue.push(s),s}catch(r){throw r}})}semanticSimilaritySearch(e,t,n=.8){return u(this,null,function*(){try{const r=yield d(e);if(!r)return[];const i=yield l(r,20,e=>e.gameId===t);return i.filter(e=>e.similarity>=n)}catch(r){return[]}})}enhanceTextContent(e){return e.replace(/\s+/g," ").trim().toLowerCase()}extractImageText(e){return u(this,null,function*(){return`Image content: ${e}`})}extractAudioText(e){return u(this,null,function*(){return`Audio content: ${e}`})}extractVideoContent(e){return u(this,null,function*(){return`Video content: ${e}`})}enhanceQueryWithContext(e){let t=e.query;return e.context.currentScene&&(t+=` scene: ${e.context.currentScene}`),e.context.emotionalState&&(t+=` emotion: ${e.context.emotionalState}`),e.context.recentTopics&&e.context.recentTopics.length>0&&(t+=` recent: ${e.context.recentTopics.slice(-3).join(", ")}`),e.context.timeContext&&(t+=` time: ${e.context.timeContext}`),t}getTopKForDepth(e){switch(e){case"shallow":return 3;case"medium":default:return 7;case"deep":return 15}}calculateContextRelevance(e,t){var n,r,i;let o=.5;return t.currentScene&&(null==(n=e.metadata)?void 0:n.scene)===t.currentScene&&(o+=.2),t.emotionalState&&(null==(r=e.metadata)?void 0:r.emotion)===t.emotionalState&&(o+=.15),t.recentTopics&&t.recentTopics.some(t=>e.text_chunk.toLowerCase().includes(t.toLowerCase()))&&(o+=.1),t.timeContext&&(null==(i=e.metadata)?void 0:i.timeContext)===t.timeContext&&(o+=.05),Math.min(o,1)}applyFocusAreaFiltering(e,t){return 0===t.length?e:e.filter(e=>t.some(t=>{var n,r;return e.text_chunk.toLowerCase().includes(t.toLowerCase())||(null==(r=null==(n=e.metadata)?void 0:n.tags)?void 0:r.some(e=>e.toLowerCase().includes(t.toLowerCase())))}))}performClustering(e,t){return u(this,null,function*(){const n=Math.max(1,Math.floor(e.length/t)),r=e.map(e=>e.embedding).filter(Boolean);let i=[];try{i=yield Fn.kMeans(r,n,10)}catch(s){i=new Array(r.length).fill(0);for(let e=0;e<r.length;e++)i[e]=e%n}const o=[];for(let t=0;t<n;t++){const n=e.filter((e,n)=>i[n]===t);if(n.length>0){const e=this.calculateCentroid(n);o.push({entries:n,centroid:e,confidence:this.calculateClusterConfidence(n,e)})}}return o})}extractClusterKeywords(e){const t={};return e.forEach(e=>{e.text_chunk.toLowerCase().split(/\s+/).forEach(e=>{e.length>3&&(t[e]=(t[e]||0)+1)})}),Object.entries(t).sort(([,e],[,t])=>t-e).slice(0,10).map(([e])=>e)}generateClusterDescription(e,t){return`Cluster focused on: ${t.slice(0,3).join(", ")}. Contains ${e.length} related entries.`}analyzeKnowledgeGaps(e,t){return u(this,null,function*(){const n=[],r=e.toLowerCase().split(/\s+/),i=yield w.table("vectorStore").where("gameId").equals(t).toArray(),o=new Set;return i.forEach(e=>{e.text_chunk.toLowerCase().split(/\s+/).forEach(e=>o.add(e))}),r.forEach(e=>{e.length>3&&!o.has(e)&&n.push(e)}),n})}generateSourceSuggestions(e,t){return u(this,null,function*(){const n=[];return e.forEach(e=>{n.push(`Search for: ${e}`),n.push(`Related to: ${t}`)}),n})}determineExpansionPriority(e,t){return"performance_gap"===e||t.length>5?"critical":"context_gap"===e||t.length>2?"high":"user_query"===e?"medium":"low"}cosineSimilarity(e,t){if(e.length!==t.length)return 0;let n=0,r=0,i=0;for(let o=0;o<e.length;o++)n+=e[o]*t[o],r+=e[o]*e[o],i+=t[o]*t[o];return 0===r||0===i?0:n/(Math.sqrt(r)*Math.sqrt(i))}euclideanDistance(e,t){if(e.length!==t.length)return 1/0;let n=0;for(let r=0;r<e.length;r++)n+=Math.pow(e[r]-t[r],2);return Math.sqrt(n)}calculateCentroid(e){var t;if(0===e.length)return[];const n=(null==(t=e[0].embedding)?void 0:t.length)||0,r=new Array(n).fill(0);return e.forEach(e=>{e.embedding&&e.embedding.forEach((e,t)=>{r[t]+=e})}),r.map(t=>t/e.length)}calculateClusterConfidence(e,t){if(0===e.length)return 0;const n=e.map(e=>e.embedding?this.euclideanDistance(e.embedding,t):1),r=n.reduce((e,t)=>e+t,0)/n.length;return Math.max(0,1-r)}initializeSemanticClustering(){this.loadExistingClusters()}loadExistingClusters(){return u(this,null,function*(){try{(yield w.table("semanticClusters").toArray()).forEach(e=>{this.semanticClusters.set(e.id,e)})}catch(e){}})}startPeriodicClustering(){setInterval(()=>u(this,null,function*(){try{const e=yield w.table("vectorStore").toArray().then(e=>[...new Set(e.map(e=>e.gameId))]);for(const t of e)yield this.createSemanticClusters(t)}catch(e){}}),36e5)}getSemanticClusters(e){return u(this,null,function*(){return Array.from(this.semanticClusters.values()).filter(t=>Array.isArray(t.entries)&&t.entries.some(t=>t.gameId===e))})}getExpansionQueue(){return u(this,null,function*(){return[...this.expansionQueue]})}clearExpansionQueue(){return u(this,null,function*(){this.expansionQueue=[]})}onMemoryAdded(e){return u(this,null,function*(){rr[e]||(rr[e]=0),rr[e]++,rr[e]>=5&&(yield this.createSemanticClusters(e),rr[e]=0)})}saveClustersToDB(e){return u(this,null,function*(){const t=yield this.getSemanticClusters(e);for(const n of t)yield w.semanticClusters.put({id:n.id,gameId:e,topic:n.name||"",relevanceScore:n.confidence||0,memories:Array.isArray(n.entries)?n.entries.map(e=>e.id):[],keywords:n.keywords||[],lastUpdated:(new Date).toISOString(),stability:1,metadata:{entityCount:0,emotionProfile:{},plotThreads:[]}})})}}const or=ir.getInstance(),sr=Object.freeze(Object.defineProperty({__proto__:null,AdvancedRAGService:ir,advancedRAG:or},Symbol.toStringTag,{value:"Module"}));class ar{constructor(){this.memoryHierarchies=new Map,this.emotionalContexts=new Map,this.consolidationQueue=[],this.forgettingThreshold=.1,this.initializeMemorySystem(),this.startPeriodicConsolidation()}static getInstance(){return ar.instance||(ar.instance=new ar),ar.instance}createMemoryNode(e,t,n,r=.5,i){return u(this,null,function*(){try{const o=yield d(e),s={id:`memory_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,type:t,content:e,importance:Math.max(0,Math.min(1,r)),emotionalValence:(null==i?void 0:i.valence)||0,emotionalArousal:(null==i?void 0:i.arousal)||.5,context:{gameId:n,timeStamp:new Date},metadata:{accessCount:0,lastAccessed:new Date,creationDate:new Date,decayRate:this.calculateDecayRate(t,r),consolidationLevel:.1},embedding:o||void 0};return yield w.table("memoryNodes").add(s),yield this.addToHierarchy(s),s}catch(o){throw o}})}retrieveMemories(e,t,n=10,r){return u(this,null,function*(){try{const i=yield d(e);if(!i)return[];const o=yield w.table("memoryNodes").where("context.gameId").equals(t).toArray();return o.map(e=>{let t=0;e.embedding&&(t+=.4*this.cosineSimilarity(i,e.embedding)),t+=.2*e.importance;const n=(Date.now()-new Date(e.metadata.creationDate).getTime())/864e5;if(t+=.2*Math.exp(-n/30),r){t+=.2*this.calculateEmotionalRelevance(e,r)}return{memory:e,relevance:t}}).sort((e,t)=>t.relevance-e.relevance).slice(0,n).map(e=>(e.memory.metadata.accessCount++,e.memory.metadata.lastAccessed=new Date,e.memory))}catch(i){return[]}})}updateEmotionalContext(e,t,n,r){return u(this,null,function*(){try{let i=this.emotionalContexts.get(e);i||(i={id:e,gameId:e,currentEmotion:{valence:0,arousal:.5,primary:"neutral",intensity:0},emotionalHistory:[],emotionalStability:.5,lastUpdated:new Date});const o=this.getEmotionalMapping(t);return i.currentEmotion={valence:o.valence,arousal:o.arousal,primary:t,intensity:Math.max(0,Math.min(1,n))},i.emotionalHistory.push({timestamp:new Date,emotion:t,intensity:n,trigger:r}),i.emotionalHistory.length>50&&(i.emotionalHistory=i.emotionalHistory.slice(-50)),i.emotionalStability=this.calculateEmotionalStability(i.emotionalHistory),i.lastUpdated=new Date,this.emotionalContexts.set(e,i),yield w.table("emotionalContexts").put(i),i}catch(i){throw i}})}consolidateMemories(e){return u(this,null,function*(){try{const t=yield w.table("memoryNodes").where("context.gameId").equals(e).toArray();let n=0;for(const e of t){const t=yield this.consolidateMemory(e);t&&(n++,yield w.table("memoryNodes").put(e),this.consolidationQueue.push(t))}return n}catch(t){return 0}})}performAdaptiveForgetting(e){return u(this,null,function*(){try{const t=yield w.table("memoryNodes").where("context.gameId").equals(e).toArray();let n=0;const r=Date.now();for(const e of t){this.shouldForgetMemory(e,r)&&(e.importance*=.5,e.metadata.decayRate*=1.5,e.importance<this.forgettingThreshold?(yield w.table("memoryNodes").delete(e.id),n++):yield w.table("memoryNodes").put(e))}return n}catch(t){return 0}})}integrateMemories(e,t){return u(this,null,function*(){try{let n=[];if(e&&e.length>=2)n=yield w.table("memoryNodes").where("id").anyOf(e).toArray();else{if(!t)return null;{const e=yield w.table("memoryNodes").where("context.gameId").equals(t).toArray(),r={};for(const t of e){const e=t.parentId||"none";r[e]||(r[e]=[]),r[e].push(t)}let i=Object.values(r).find(e=>e.length>=2);if(!i){const t={};for(const n of e){const e=n.type;t[e]||(t[e]=[]),t[e].push(n)}i=Object.values(t).find(e=>e.length>=2)}if(!i)return null;n=i}}if(n.length<2)return null;const r=this.createIntegratedContent(n),i=n.reduce((e,t)=>e+t.importance,0)/n.length,o=n.reduce((e,t)=>e+t.emotionalValence,0)/n.length,s=n.reduce((e,t)=>e+t.emotionalArousal,0)/n.length,a=yield this.createMemoryNode(r,"semantic",n[0].context.gameId,i,{valence:o,arousal:s});for(const e of n)e.context.relatedMemories||(e.context.relatedMemories=[]),e.context.relatedMemories.push(a.id),e.importance<.2?yield w.table("memoryNodes").delete(e.id):yield w.table("memoryNodes").put(e);return yield this.pruneMemoriesIfNeeded(n[0].context.gameId),a}catch(n){return null}})}calculateDecayRate(e,t){return{episodic:.1,semantic:.05,emotional:.15,procedural:.08}[e]*(1-.5*t)}addToHierarchy(e){return u(this,null,function*(){const t=e.context.gameId;let n=this.memoryHierarchies.get(t);n||(n={id:t,name:`Memory Hierarchy - ${t}`,level:"core",memories:[],children:[],importance:0,lastUpdated:new Date},this.memoryHierarchies.set(t,n)),this.determineHierarchyLevel(e),n.memories.push(e),n.importance=Math.max(n.importance,e.importance),n.lastUpdated=new Date,yield w.table("memoryHierarchies").put(n)})}determineHierarchyLevel(e){return e.importance>.8?"core":e.importance>.6?"important":e.importance>.3?"contextual":"temporary"}cosineSimilarity(e,t){if(e.length!==t.length)return 0;let n=0,r=0,i=0;for(let o=0;o<e.length;o++)n+=e[o]*t[o],r+=e[o]*e[o],i+=t[o]*t[o];return 0===r||0===i?0:n/(Math.sqrt(r)*Math.sqrt(i))}calculateEmotionalRelevance(e,t){const n=Math.abs(e.emotionalValence-t.currentEmotion.valence),r=Math.abs(e.emotionalArousal-t.currentEmotion.arousal);return Math.max(0,1-(n+r)/2)}getEmotionalMapping(e){const t={joy:{valence:.8,arousal:.7},sadness:{valence:-.6,arousal:.3},anger:{valence:-.4,arousal:.9},fear:{valence:-.7,arousal:.8},surprise:{valence:.2,arousal:.8},disgust:{valence:-.8,arousal:.6},neutral:{valence:0,arousal:.5}};return t[e]||t.neutral}calculateEmotionalStability(e){if(e.length<2)return.5;let t=1;for(let n=1;n<e.length;n++){const r=e[n-1],i=e[n];t-=.1*Math.abs(i.intensity-r.intensity)}return Math.max(0,Math.min(1,t))}consolidateMemory(e){return u(this,null,function*(){const t=Date.now()-new Date(e.metadata.lastAccessed).getTime(),n=e.metadata.accessCount/(t/864e5);let r="strengthening",i=0;return n>5?(r="strengthening",i=Math.min(1,e.metadata.consolidationLevel+.1)):n<.1?(r="weakening",i=Math.max(0,e.metadata.consolidationLevel-.05)):(r="integration",i=e.metadata.consolidationLevel),i!==e.metadata.consolidationLevel?(e.metadata.consolidationLevel=i,{id:`consolidation_${Date.now()}`,memoryId:e.id,type:r,strength:i,trigger:"periodic_consolidation",timestamp:new Date,duration:1e3}):null})}shouldForgetMemory(e,t){const n=.3*((t-new Date(e.metadata.creationDate).getTime())/31536e6)+.4*((t-new Date(e.metadata.lastAccessed).getTime())/2592e6)+.3*(1-e.importance);return Math.random()<n*e.metadata.decayRate}createIntegratedContent(e){const t=e.map(e=>e.content),n=this.extractCommonKeywords(t);return`Integrated memory combining ${e.length} related experiences. Key themes: ${n.join(", ")}. This represents a higher-level understanding of the connected concepts.`}extractCommonKeywords(e){const t={};return e.forEach(e=>{e.toLowerCase().split(/\s+/).forEach(e=>{e.length>3&&(t[e]=(t[e]||0)+1)})}),Object.entries(t).filter(([,e])=>e>1).sort(([,e],[,t])=>t-e).slice(0,5).map(([e])=>e)}initializeMemorySystem(){this.loadExistingData()}loadExistingData(){return u(this,null,function*(){try{const e=yield w.table("memoryHierarchies").toArray(),t=yield w.table("emotionalContexts").toArray();e.forEach(e=>this.memoryHierarchies.set(e.id,e)),t.forEach(e=>this.emotionalContexts.set(e.gameId,e))}catch(e){}})}startPeriodicConsolidation(){setInterval(()=>u(this,null,function*(){try{const e=yield w.table("memoryNodes").toArray().then(e=>[...new Set(e.map(e=>e.context.gameId))]);for(const t of e)yield this.consolidateMemories(t),yield this.performAdaptiveForgetting(t)}catch(e){}}),18e5)}getMemoryHierarchy(e){return u(this,null,function*(){return this.memoryHierarchies.get(e)||null})}getEmotionalContext(e){return u(this,null,function*(){return this.emotionalContexts.get(e)||null})}getConsolidationQueue(){return u(this,null,function*(){return[...this.consolidationQueue]})}clearConsolidationQueue(){return u(this,null,function*(){this.consolidationQueue=[]})}moveMemoryNode(e,t,n){return u(this,null,function*(){let r=yield w.table("memoryHierarchies").get(n);if(!r)return;const i=r.memories.findIndex(t=>t.id===e);if(-1===i)return;const o=r.memories[i];r.memories.splice(i,1);let s=r;if(r.level!==t){let e=`${n}_${t}`,i=yield w.table("memoryHierarchies").get(e);i||(i={id:e,name:`Memory Hierarchy - ${n} - ${t}`,level:t,memories:[],parentId:n,children:[],importance:0,lastUpdated:new Date},yield w.table("memoryHierarchies").add(i),r.children.includes(e)||r.children.push(e)),s=i}s.memories.push(o),s.lastUpdated=new Date,yield w.table("memoryHierarchies").put(s),yield w.table("memoryHierarchies").put(r)})}updateMemoryImportance(e,t,n){return u(this,null,function*(){let r=yield w.table("memoryHierarchies").get(n);if(!r)return;const i=r.memories.findIndex(t=>t.id===e);if(-1===i)return;const o=r.memories[i];o.importance=t;const s=this.determineHierarchyLevel(o);r.level!==s?yield this.moveMemoryNode(e,s,n):(r.memories[i]=o,yield w.table("memoryHierarchies").put(r)),yield w.table("memoryNodes").put(o)})}deleteMemoryNode(e,t){return u(this,null,function*(){let n=yield w.table("memoryHierarchies").get(t);n&&(n.memories=n.memories.filter(t=>t.id!==e),yield w.table("memoryHierarchies").put(n),yield w.table("memoryNodes").delete(e))})}getMemoriesByLevel(e,t){return u(this,null,function*(){let n=yield w.table("memoryHierarchies").get(`${e}_${t}`);return n?n.memories:[]})}getMemoryHierarchyTree(e){return u(this,null,function*(){const t=yield w.table("memoryHierarchies").get(e);if(!t)return null;const n=e=>u(null,null,function*(){if(!e.children||0===e.children.length)return e;const t=yield w.table("memoryHierarchies").where("id").anyOf(e.children).toArray();return e.children=t.map(e=>e.id),e.childrenNodes=yield Promise.all(t.map(n)),e});return yield n(t)})}getContextForAI(e,t=10,n){return u(this,null,function*(){if(n){const r=yield d(n);if(r&&Array.isArray(r)){const n=tr({embeddingVector:r,requiredTags:[],edgeTypes:["emotion","goal","motivation","location","event-type","related","cause-effect"],minConfidence:.5,maxAgeMs:2592e6,limit:t}),i=yield w.table("memoryNodes").where("context.gameId").equals(e).toArray(),o=n.map(e=>i.find(t=>t.id===e.id)).filter(e=>!!e);if(o.length>0)return o}}let r=[],i=[];if(n&&void 0!==gn){const t=n.trim();gn.hasNode(t)&&(r=[...yn(t,"related"),...yn(t,"topic"),...yn(t,"cluster")],i=r.map(e=>gn.getNodeAttributes(e)).filter(t=>t&&t.id&&t.type&&t.content&&void 0!==t.importance&&t.context&&t.metadata&&t.context.gameId===e))}let o=[];if(void 0!==gn){const n=gn.nodes().filter(e=>gn.getNodeAttribute(e,"topic")),r=new Set;for(const i of n){if(!gn.hasNode(i))continue;const n=yn(i,"cluster");for(const i of n){const n=gn.getNodeAttributes(i);if(n&&n.id&&n.type&&n.content&&void 0!==n.importance&&n.context&&n.metadata&&n.context.gameId===e&&!r.has(n.id)&&(o.push(n),r.add(n.id),o.length>=t))break}if(o.length>=t)break}}let s=[...i];for(const e of o){if(s.length>=t)break;s.find(t=>t.id===e.id)||s.push(e)}if(s.length<t){const r=["core","important","contextual","temporary"];let i=[];for(const n of r){const r=yield this.getMemoriesByLevel(e,n);for(const e of r){if(!(i.length<t))break;i.push(e)}if(i.length>=t)break}if(n&&i.length>0){const e=yield d(n);e&&i.sort((t,n)=>{const r=t.embedding?this.cosineSimilarity(e,t.embedding):0;return(n.embedding?this.cosineSimilarity(e,n.embedding):0)-r})}const o=new Set,a=[];for(const e of i){const n=e.type+(e.context.scene||"");if(o.has(n)||(a.push(e),o.add(n)),a.length>=t)break}for(const e of a){if(s.length>=t)break;s.find(t=>t.id===e.id)||s.push(e)}}return s.slice(0,t)})}pruneMemoriesByHierarchy(e,t){return u(this,null,function*(){const n=["temporary","contextual","important","core"];let r=0,i=0;const o=[];for(const t of n){const n=yield this.getMemoriesByLevel(e,t);for(const e of n)o.push({node:e,level:t})}if(r=o.length,r<=t)return 0;const s=o.slice(0,r-t);for(const{node:t,level:a}of s)yield this.deleteMemoryNode(t.id,"core"===a?e:`${e}_${a}`),i++;return i})}pruneMemoriesIfNeeded(e,t=500){return u(this,null,function*(){const n=yield w.table("memoryNodes").where("context.gameId").equals(e).toArray();if(n.length<=t)return 0;const r={temporary:0,contextual:1,important:2,core:3};n.sort((e,t)=>r[this.determineHierarchyLevel(e)]-r[this.determineHierarchyLevel(t)]||e.importance-t.importance);const i=n.slice(0,n.length-t);for(const t of i)yield this.deleteMemoryNode(t.id,e);return i.length})}}const cr=ar.getInstance(),ur=Object.freeze(Object.defineProperty({__proto__:null,AdvancedMemoryService:ar,advancedMemory:cr},Symbol.toStringTag,{value:"Module"}));export{kn as A,z as B,P as C,U as D,$ as E,R as F,H as G,En as H,nr as I,ur as J,er as M,Fn as a,x as b,M as c,w as d,O as e,b as f,j as g,I as h,C as i,k as j,L as k,_ as l,N as m,G as n,or as o,cr as p,gn as q,mn as r,E as s,fn as t,wn as u,q as v,v as w,A as x,W as y,S as z};
